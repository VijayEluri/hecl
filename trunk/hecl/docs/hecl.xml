<?xml version="1.0" encoding="iso-8859-1"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
  "http://www.oasis-open.org/committees/docbook/xml/4.1.2/docbookx.dtd" []>

<!--
   Copyright 2004-2005 David N. Welton

   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License.  You
   may obtain a copy of the License at

   	http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied.  See the License for the specific language governing
   permissions and limitations under the License.
-->

<!-- $Id$ -->

<article>
  <articleinfo>
    <title>
      <ulink url="http://www.hecl.org/">
	Hecl Programming Language
      </ulink>
    </title>
    <copyright>
      <year>2004</year>
      <year>2005</year>
      <holder>
	David N. Welton
      </holder>
    </copyright>
    <author>
      <firstname>David</firstname>
      <surname>Welton</surname>
      <affiliation>
	<orgname>DedaSys</orgname>
	<address>
	  <email>davidw@dedasys.com</email>
	</address>
      </affiliation>
    </author>
  </articleinfo>

  <section>
    <title>Introduction</title>
    <para>
      The Hecl Programming Language is a high-level scripting language
      implemented in Java.  It is intended to be small, extensible,
      extremely flexible, and easy to learn and use.
    </para>

    <para>
      Why Hecl?  Hecl is intended as a complement to the Java
      programming language, not a replacement.  It tries to do well
      what Java doesn't, and leaves those tasks to Java for which it
      is best suited, by providing an API that makes it easy to tie
      the two together.  Hecl aims to be a very immediate language -
      you can pick it up and start doing useful things with it quickly
      - even people without formal training.  Hecl is easy to learn.
      Where Java is verbose and rigid, Hecl is forgiving and quick to
      write.  For instance,
      <userinput>System.out.println("Hello World");</userinput>
      vs <userinput>puts "Hello World"</userinput> - 41
      keystrokes (shifted letters count double) versus 22.  Hecl is
      built to <ulink
      url="http://www.dedasys.com/articles/scalable_systems.html">"scale
      down"</ulink> - especially in terms of its users, meaning that
      it is very quick to learn, and can be quickly put to productive
      use even by those who are not programmers by trade.
    </para>

    <para>
      This makes Hecl ideal for large applications written in Java
      that would like to provide a user friendly scripting interface,
      rather than, say, a clunky XML based system.  Examples include:
      scripted web pages, command/control logic in long running
      applications, and, I'm sure, many environments I've never
      considered.  Instead of a simple, static configuration file, you
      can give your users the power to program portions of the system
      to do things that you hadn't thought of when you wrote the
      software originally.
    </para>

    <para>
      Hecl is a small language with a minimal core.  The idea is to
      provide only what's necessary in the language itself, and as
      needed, add in extensions for specific tasks.  Core Hecl is
      small enough to run on my Nokia 3100 cell phone as a J2ME
      application, presenting the interesting possibility of writing
      scripts, or at some point, maybe even scripting entire
      applications, for devices running embedded Java.
    </para>

    <para>
      Contributions in the form of code, ideas, suggestions, or even
      donations are welcome.  Hecl is still growing, so your thoughts
      are important, and you can help shape the language's future.
      You can download the code via CVS from the SourceForge project
      page: <ulink
      url="http://sourceforge.net/projects/hecl/">http://sourceforge.net/projects/hecl/</ulink>.
    </para>

    <para>
      Hecl is available under the liberal Apache 2.0 open source
      license.  Which says, more or less, that you may use Hecl in
      your own applications, even if they are not open source.  You
      have to give me credit, though.  Read the license itself to
      clear up any doubts.  Oh, and incidentally, I don't see the
      license as being incompatible with the GPL, so feel free to
      utilize Hecl in your GPL product (I have added a note to this
      effect in the NOTICE file that must accompany products using the
      Hecl code).
    </para>

    <para>
      I owe thanks to a lot of people for Hecl.  First and foremost
      the creator of the Tcl programming language, Dr. John
      Ousterhout.  While I have attempted to improve some things that
      I did not care for in Tcl, it is obvious that the simple,
      extremely flexible command-based approach that Hecl takes is
      derived from Tcl.  I also borrowed some ideas from the (mostly
      defunct) Jacl implementation of Tcl in Java.  Many thanks are
      also due my friend Salvatore Sanfilippo, with whom I have spent
      many hours discussing Hecl, Tcl, and the philosophy of
      programming languages in general.  And of course, I owe a huge
      debt of gratitude to my wife, Ilenia, who puts up with all the
      hours I spend in front of "that damn computer".
    </para>

  </section>

  <section id="installation">
    <title>Installation</title>
    <para>Hecl is easy to compile and install as a standard J2SE application.</para>
    <procedure>
      <step>
	Hecl uses the <link url="http://ant.apache.org/">Apache
	Ant</link> build system, so you need to install that to
	compile Hecl.
      </step>
      <step>
	To compile the standard, J2SE version of Hecl, do this:
	<screen>
ant packageCommandline
</screen>
      </step>
      <step>
	You should now have a Hecl.jar file.  To run it, do this:
	<screen>
java -jar Hecl.jar Hecl
hecl> puts "hello world"
hello world
</screen>
      </step>
      <step>
	If you wish, you can compile Hecl to native code with GCJ:
	<screen>
gcj -o hecl --main=Hecl Hecl.jar
davidw@medford:~/workshop/hecl$ ./hecl
hecl> puts "hello world"
hello world
	</screen>
      </step>
      <step>
	If you want to check your installation of Hecl, you can run
	the test suite to make sure everything checks out:
	<screen>
java -classpath Hecl.jar Hecl tests/suite.hcl
	</screen>
	A performance test is also supplied so that you can compare
	numbers if you're curious, or want to hack on Hecl to improve
	its speed:
	<screen>
java -classpath Hecl.jar Hecl tests/performance.hcl
	</screen>
      </step>
    </procedure>

  </section>

  <section id="tutorial">
    <title>Hecl Tutorial</title>
    <para>
      Like many people, I enjoy taking something and experimenting
      with it before going and reading the instructions!  With this in
      mind, I have written a brief tutorial that you can use to start
      exploring Hecl on your own.
    </para>

    <para>
      Of course, we would be out of place not to begin with the famous
      "Hello, World".  Behold:
    </para>
    <programlisting>puts "Hello, World"</programlisting>
    <para>
      Hecl is based on the notion of commands, which take any number
      of arguments.  The <command>puts</command> command takes one
      argument, a string, and prints it out.
    </para>
    <para>
      Like all programming languages, Hecl provides variables that may
      be used to store information. Here, we set a variable,
      <varname>rating</varname>, and then print it out in the midst of
      a string.  This is called "interpolation", and is a convenient
      way of creating new strings.
    </para>
	    <programlisting>set rating 10
puts "Hecl, from 1 to 10: $rating"</programlisting>
    <para>
      Something else we notice in the above examples is that we use
      double quotes "" to group a series of things.  In Hecl, commands
      and their arguments are separated by spaces.  Since
      <command>puts</command> only takes one argument, a string, we
      use the quotes to group several words together in order to pass
      them as one string to the command.  Many languages require
      quotes to delineate a string, but in Hecl that is not necessary
      if the string has no spaces in it.  For instance,
      <userinput>puts helloworld</userinput> is legitimate.
    </para>

    <para>
      Another way of grouping multiple words in Hecl is with braces:
      {}.  Hecl does not automatically perform any substitution on the
      variables or commands grouped within braces, as it does with
      quotes.
    </para>

    <programlisting>puts {The $dollar $signs $are printed	    literally$$ - no substitution}</programlisting>

    <para>
      Aside from the dollar sign, which returns a copy of the value of
      a variable, it is also possible to utilize the results of one
      command as the input of a second command.  For example:
    </para>

    <programlisting>set rating 10
puts "Rating:"
puts [set rating]</programlisting>

    <para>
      In this case, we pass the results of the <command>set</command>
      command to the <command>puts</command> command.  In reality, <userinput>set
	rating</userinput> is just a long way of writing
      <option>$rating</option> but it's a good example.
    </para>

    <para>
      Like everything else in Hecl, we perform math operations as
      commands:
    </para>

    <programlisting>puts "2 + 2 = [+ 2 2]"</programlisting>

    <para>
      In the example, the <command>+</command> takes two arguments,
      adds them together and return the result, which is then printed
      out by the <command>puts </command> command.
    </para>

    <para>
      In order to choose between one or more 
    </para>

    <programlisting>set temp 10
if { &lt; $temp 0 } {
    puts "It's freezing"
} else {
    puts "Not freezing"
}</programlisting>

    <para>References:</para>

    <programlisting>set a 1
set b &amp;a
puts $b
# Returns '1'
set a 2
puts $b
# Returns '2'</programlisting>

    <para>"while" loop command:</para>

    <programlisting>set i 0
while { &lt; &amp;i 10 } {
    puts "i is now $i"
    incr &amp;i
}
</programlisting>

    <para>Lists:</para>

    <programlisting>set foo [list a b c]
set bar {a b c}
lappend &amp;foo d
lappend &amp;bar d
set foo
# Returns 'a b c d'
set bar
# Returns 'a b c d'
</programlisting>

    <para>Hash tables:</para>

    <programlisting>set foo [hash {a b c d}]
puts [hget &amp;foo a]
# prints 'b'
puts [hget &amp;foo c]
# prints 'd'
hset &amp;foo c 2
puts [hget &amp;foo c]
# prints '2'
puts $foo
# prints 'a b c 2' (although not necessarily in that order)
</programlisting>

    <para>"foreach" loop command:</para>

    <programlisting>set lst {a b c d e f}
foreach {m n} $lst {
    puts  "It is possible to grab two variables at a time: $m $n"
}

foreach {x} $lst {
    puts  "Or one at a time: $x"
}</programlisting>

    <para>
      Create new commands with the "proc" command.  In this example we
      create a command that prints out a numbered list.
    </para>

    <programlisting>set list {red blue green}
proc printvals {vals} {
    set num 1
    foreach v $vals {
	puts "$num - $v"
	incr &amp;num
    }
}

printvals &amp;list</programlisting>

    <para>
      Hecl is very flexible - in this example, we create a
      "do...while" loop command that works as if it were a native loop
      construct.
    </para>

    <programlisting>proc do {code while condition} {
    upeval $code
    while { upeval &amp;condition } {
	upeval $code
    }
}

set x 100
set foo ""
do {
    append &amp;foo $x
    incr &amp;x
} while { &lt; &amp;x 10 }
set foo
# Returns 100 - because the loop is run once and only once.
</programlisting>

  </section>

  <section id="commands">
    <title>Hecl Commands</title>


    <!-- + - * / math commands -->
    <refentry id="math">
      <refnamediv>
	<refname>+ - * /</refname>
	<refpurpose>Basic math commands.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>+</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="opt" rep="repeat"><replaceable>number</replaceable></arg>
	  <command>-</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <command>*</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <command>/</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The basic math commands take two arguments and carry out a
	  numerical operation on them.  In subtraction, the second
	  argument is taken from the first.  In division, the first
	  argument is divided by the second.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [+ 2 2]
puts [+ 1 2 3]
puts [- 10 1]
puts [* 6 7]
puts [/ 100 5]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2
6
9
42
20</screen>
      </refsect1>
    </refentry>



    <!-- append -->
    <refentry id="append">
      <refnamediv>
	<refname>append</refname>
	<refpurpose>Append text to a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>append</command>
	  <arg choice="req"><replaceable>varreference</replaceable></arg>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The append command takes two arguments, a variable reference, and a string to append to the variable.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo "bar"
append &amp;foo "beebop"
# The foo variable now contains the string barbeebop
	  </programlisting>
	  <para>Produces:</para>
	  <screen>barbeebop</screen>
      </refsect1>
    </refentry>

    <!-- break -->
    <refentry id="break">
      <refnamediv>
	<refname>break</refname>
	<refpurpose>Break out of a loop.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>break</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The break command breaks out of a loop.  If this command is
	  not run from within a loop - the <command>while</command> or
	  <command>foreach</command> commands for instance, it
	  generates an error.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set i 0
while { true } {
    if { > $i 100 } {
        break
    }
    incr &amp;i
}
	  </programlisting>
	<para>
	  In what would otherwise be an endless loop, the break
	  command is used to exit.
	</para>
      </refsect1>
    </refentry>

    <!-- catch -->
    <refentry id="catch">
      <refnamediv>
	<refname>catch</refname>
	<refpurpose>
	  Evaluates a script, catching any errors.
	</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>catch</command>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	  <arg choice="opt"><replaceable>varname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The catch command evaluates a script, and returns 0 if the
	  script evaluated successfully.  If there were errors, catch
	  returns 1.  Optionally, a variable name may be passed to the
	  command, where the results of the script evaluation will be
	  placed.  In the case of errors, the stack trace will be
	  placed in the variable argument.  If the script executes
	  without problems, the variable will contain the result of
	  the script execution.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
catch nosuchcommand foo
set foo
	  </programlisting>
	  <para>Produces:</para>
	<screen>
	  {ERROR {Command nosuchcommand does not exist}}
	</screen>
      </refsect1>
    </refentry>


    <!-- continue -->
    <refentry id="continue">
      <refnamediv>
	<refname>continue</refname>
	<refpurpose>Skip to next cycle of a loop</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>continue</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The continue command is used within the bodies of looping
	  commands such as <command>if</command> and
	  <command>while</command>.  When <command>continue</command>
	  is called, execution of the loop body stops and and
	  execution moves on to the next iteration of the loop.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
set i 0
set res {}
foreach x {a b c d e} {
    incr &amp;i
    continue
    append &amp;res $x
}
puts $i
puts $res
	</programlisting>
	<para>Produces:</para>
	<screen>5</screen>
	<para>
	  The res variable is never appended to, so printing it out
	  produces an empty string.
	</para>
      </refsect1>
    </refentry>

    <!-- eq -->
    <refentry id="eq">
      <refnamediv>
	<refname>eq</refname>
	<refpurpose>Tests string equivalence.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>eq</command>
	  <arg choice="req"><replaceable>string1</replaceable></arg>
	  <arg choice="req"><replaceable>string2</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>eq</command> commands compares two strings,
	  returning 1 if they are equal, 0 if they are not.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if {eq 1 1.0} {
    puts "True"
} else {
    puts "False"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>False</screen>

	<para>
	  Despite being numerically equivalent, the strings "1" and
	  "1.0" are different.
	</para>
      </refsect1>
    </refentry>

    <refentry id="eval">
      <refnamediv>
	<refname>eval</refname>
	<refpurpose>Evaluate Hecl code.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>eval</command>
	  <arg choice="req"><replaceable>code</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>eval</command> command takes a string
	  containing Hecl commands, evaluates them, and returns the
	  result.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set i 0
set str {incr}
lappend &amp;str "i"
eval $str
puts $i
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1</screen>
      </refsect1>
    </refentry>

    <refentry id="filter">
      <refnamediv>
	<refname>filter</refname>
	<refpurpose>Filter a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>filter</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>filter</command> command takes a list and
	  filters it according to the code provided in
	  <option><replaceable>code</replaceable></option>.  The
	  current element of the list being considered is stored in
	  the <option><replaceable>varname</replaceable></option>
	  provided.  A list of 'matches' is returned.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set lst {1 2 3 4 5 4 3 2 1}
puts [filter $lst x {= $x 4}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4 4</screen>
      </refsect1>
    </refentry>

    <refentry id="for">
      <refnamediv>
	<refname>for</refname>
	<refpurpose>For loop.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>for</command>
	  <arg choice="req"><replaceable>initialization</replaceable></arg>
	  <arg choice="req"><replaceable>test</replaceable></arg>
	  <arg choice="req"><replaceable>step</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>for</command> command is like in many other
	  languages like C and Java.  As arguments, it takes an
	  <option><replaceable>initialization</replaceable></option>
	  option, which is often used to set a variable to some
	  initial value, a
	  <option><replaceable>test</replaceable></option> to
	  determine whether to continue running, a
	  <option><replaceable>step</replaceable></option> script
	  option which is run at each iteration of the body (to
	  increment a variable, for example), and the body itself.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set out {}
for {set i 0} {&lt; $i 10} {incr &amp;i} {
    append &amp;out $i
}
puts $out
	  </programlisting>
	  <para>Produces:</para>
	  <screen>0123456789</screen>
      </refsect1>
    </refentry>

    <refentry id="foreach">
      <refnamediv>
	<refname>foreach</refname>
	<refpurpose>Iterate over elements in a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>foreach</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	  <command>foreach</command>
	  <arg choice="req"><replaceable>varlist</replaceable></arg>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The foreach command iterates over a list.  For each element
	  of the list,
	  <option><replaceable>varname</replaceable></option> is set
	  to a new element of the list, and then
	  <option><replaceable>body</replaceable></option> is run.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set lst {a b c d e}
set res {}
foreach el $lst {
    append &amp;res $el
}
puts $res
	  </programlisting>
	  <para>Produces:</para>
	  <screen>abcde</screen>
      </refsect1>
    </refentry>

    <!-- global -->
    <refentry id="global">
      <refnamediv>
	<refname>global</refname>
	<refpurpose>Use global variable from within a proc.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>global</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="opt" rep="repeat"><replaceable>varname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  By default, Hecl variables are always local.  Global
	  variables are not visible from within procedures.  The
	  <command>global</command> command makes global variable
	  <option><replaceable>varname</replaceable></option> visible
	  within a procedure.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo 1
proc incfoo {} {
    global foo
    incr &amp;foo
}
incfoo
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2</screen>
      </refsect1>
    </refentry>

    <!-- hash, hget, hset -->
    <refentry id="hash">
      <refnamediv>
	<refname>hash</refname>
	<refpurpose>Create and manipulate hash tables.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>hash</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <command>hget</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	  <command>hset</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	  <arg choice="req"><replaceable>value</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>hash</command> command takes an even-numbered
	  list and creates a hash table from it, using the even
	  elements as keys, and odd elements as values.  A new hash
	  table is returned.  The <command>hget</command> and
	  <command>hset</command> commands operate on hash tables.
	  Both take a hash table as their first argument.
	  <command>hget</command> also takes a key, and returns the
	  corresponding value, or an error if no key by that name
	  exists.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo [hash {a b c d}]
hset &amp;foo a 42
puts [hget &amp;foo a]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>42</screen>
      </refsect1>
    </refentry>

    <!-- if -->
    <refentry id="if">
      <refnamediv>
	<refname>if</refname>
	<refpurpose>Conditionally execute code.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>if</command>
	  <arg choice="req"><replaceable>test</replaceable></arg>
	  <arg choice="req"><replaceable>code</replaceable></arg>
	  <group choice="opt" rep="repeat">
	    <arg choice="req"><option>elseif</option></arg>
	    <arg choice="req"><replaceable>test</replaceable></arg>
	    <arg choice="req"><replaceable>code</replaceable></arg>
	  </group>
	  <group choice="opt">
	    <arg choice="req"><option>else</option></arg>
	    <arg choice="req"><replaceable>code</replaceable></arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The if command executes Hecl code conditionally.  In its
	  most basic form, it executes a
	  <option><replaceable>test</replaceable></option>.  If the
	  results are not 0, then it executes
	  <option><replaceable>code</replaceable></option>.  If not,
	  no further actions take place.  <command>if</command> may
	  take any number of <option>elseif</option> clauses, which
	  have their own
	  <option><replaceable>test</replaceable></option> and
	  <option><replaceable>code</replaceable></option>.  Finally,
	  if none of the conditions has matched, it is also possible
	  to supply an <option>else</option> clause that will be
	  executed if the results of the if and elseif tests were all
	  false.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if { true } {
    puts "true"
} else {
    puts "false"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>true</screen>
	  <programlisting>
if { > 0 1 } {
    puts "true"
} else {
    puts "false"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>false</screen>
      </refsect1>
    </refentry>

    <!-- incr -->
    <refentry id="incr">
      <refnamediv>
	<refname>incr</refname>
	<refpurpose>Increment a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>incr</command>
	  <arg choice="req"><replaceable>varreference</replaceable></arg>
	  <arg choice="req"><replaceable>integer</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>incr</command> command takes a variable
	  reference, and adds <option><replaceable>integer to
	  it</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo 1
incr &amp;foo
puts "foo is $foo"
incr &amp;foo 10
puts "foo is now $foo"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2
12</screen>
      </refsect1>
    </refentry>

    <!-- intro -->
     <refentry id="intro">
      <refnamediv>
	<refname>intro</refname>
	<refpurpose>Introspection command.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>intro</command>
	  <group>
	    <arg choice="req">commands</arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>intro</command> command is used for Hecl
	  introspection.  It takes a subcommand which causes it to
	  perform the desired function.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
 puts [sort [intro commands]]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>* + - / &lt; = &gt; append break catch continue copy eq eval filter for foreach global hash hget hset if incr intro join lappend lindex list llen lset proc puts ref return search set sindex slen sort source sourcehere split time true upeval while</screen>
      </refsect1>
    </refentry>

    <!-- join -->
     <refentry id="join">
      <refnamediv>
	<refname>join</refname>
	<refpurpose>Join elements of a list to create a string.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>join</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="opt"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>join</command> command takes a
	  <option><replaceable>list</replaceable></option> argument,
	  and optionally, a
	  <option><replaceable>string</replaceable></option>
	  argument.  It joins all elements of the list together with
	  the string, or, if a string is not provided, with a space.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [join {a b c} "|"]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a|b|c</screen>
      </refsect1>
    </refentry>

    <!-- lappend -->
     <refentry id="lappend">
      <refnamediv>
	<refname>lappend</refname>
	<refpurpose>Append an element to a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lappend</command>
	  <arg choice="req"><replaceable>listreference</replaceable></arg>
	  <arg choice="req"><replaceable>element</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lappend</command> takes a reference to a list,
	  and an element to add to that list.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo a
lappend &amp;foo "b"
puts $foo
lappend &amp;foo "c d"
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a b
a b {c d}</screen>
      </refsect1>
    </refentry>

    <!-- lindex -->
    <refentry id="lindex">
      <refnamediv>
	<refname>lindex</refname>
	<refpurpose>Return the Nth element of a list</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lindex</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>index</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lindex</command> command takes a list and an
	  index number as arguments, and return's the index'th element
	  of the list.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
puts [lindex {a b c} 2]
	</programlisting>
	<para>Produces:</para>
	<screen>c</screen>
      </refsect1>
    </refentry>


    <!-- list -->
     <refentry id="list">
      <refnamediv>
	<refname>list</refname>
	<refpurpose>Create a list</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>list</command>
	  <arg choice="req"><replaceable>element</replaceable></arg>
	  <group choice="opt" rep="repeat">
	    <arg choice="req"><replaceable>element</replaceable></arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>list</command> command takes any number of
	  arguments and returns a list.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
puts [list a b c [list 1 2 3]]
	</programlisting>
	<para>Produces:</para>
	<screen>a b c {1 2 3}</screen>
      </refsect1>
    </refentry>

    <!-- llen -->
     <refentry id="llen">
      <refnamediv>
	<refname>llen</refname>
	<refpurpose>List length.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>llen</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>llen</command> returns the length of its list
	  argument.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [llen {1 2 3 {a b c}}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4</screen>
      </refsect1>
    </refentry>

     <!-- lset -->
     <refentry id="lset">
      <refnamediv>
	<refname>lset</refname>
	<refpurpose>Set list elements.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lset</command>
	  <arg choice="req"><replaceable>listref</replaceable></arg>
	  <arg choice="req"><replaceable>index</replaceable></arg>
	  <arg choice="opt"><replaceable>replacement</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lset</command> command sets the
	  <option><replaceable>index</replaceable></option>'th element
	  of the list to
	  <option><replaceable>replacement</replaceable></option>.  If
	  <option><replaceable>replacement</replaceable></option> is
	  not present, then the element is deleted.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
    set lst {a b c}
    lset &amp;lst 1 x
    puts $lst

    lset &amp;lst 1
    puts $lst
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a x c
a c</screen>
      </refsect1>
    </refentry>

     <!-- proc -->
     <refentry id="proc">
      <refnamediv>
	<refname>proc</refname>
	<refpurpose>Create a new procedure.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>proc</command>
	  <arg choice="req"><replaceable>name</replaceable></arg>
	  <arg choice="req"><replaceable>arglist</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>proc</command> command creates new procedures,
	  which are virtually indistinguishable from built-in Hecl
	  commands.  <option><replaceable>name</replaceable></option>
	  is the name of the new command,
	  <option><replaceable>arglist</replaceable></option> is a
	  list of arguments that the new command will take and make
	  available as local variables within the
	  <option><replaceable>body</replaceable></option>, which is
	  the code executed every time the command is called.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
proc addlist {lst} {
    set res 0
    foreach e &amp;lst {
	incr &amp;res $e
    }
    return &amp;res
}

puts [addlist {1 2 3 4 5}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>15</screen>
      </refsect1>
    </refentry>

     <!-- puts -->
     <refentry id="puts">
      <refnamediv>
	<refname>puts</refname>
	<refpurpose>Print text.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>puts</command>
	  <arg choice="req"><replaceable>text</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>puts</command> command prints
	  <option><replaceable>text</replaceable></option> to stdout.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts "Hello, world"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>Hello, world</screen>
      </refsect1>
    </refentry>

    <!-- return -->
    <refentry id="return">
      <refnamediv>
	<refname>return</refname>
	<refpurpose>Returns a value from a procedure.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>return</command>
	  <arg choice="req"><replaceable>value</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>return</command> command returns a value from a
	  <command>proc</command> command.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
proc someproc {} {
    set res 1
    return &amp;res
    set res 2
    return &amp;res
}
puts [someproc]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1</screen>
      </refsect1>
    </refentry>

    <!-- search -->
    <refentry id="search">
      <refnamediv>
	<refname>search</refname>
	<refpurpose>Find the first instance of something in a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>search</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>search</command> command is similar to
	  <command>filter</command> in functionality, except that it
	  stops searching on the first match.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set lst {1 2 3 4 5 4 3 2 1}
puts [search $lst x {= $x 4}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4</screen>
      </refsect1>
    </refentry>

    <!-- set -->
    <refentry id="set">
      <refnamediv>
	<refname>set</refname>
	<refpurpose>Set a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>set</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="opt"><replaceable>value</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>set</command> sets the value of a variable
	  <option><replaceable>varname</replaceable></option> to value
	  <option><replaceable>value</replaceable></option>. If
	  <option><replaceable>value</replaceable></option> is not
	  provided, returns the value of
	  <option><replaceable>varname</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo "bar"
set bee bop
puts "foo is $foo and bee is $bee"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1
foo is bar and bee is bop
</screen>
      </refsect1>
    </refentry>

     <!-- sindex -->
     <refentry id="sindex">
      <refnamediv>
	<refname>sindex</refname>
	<refpurpose>Return the index'th character of string.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>sindex</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="req"><replaceable>index</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>sindex</command> command returns the
	  <option><replaceable>index</replaceable></option>'th
	  character of <option><replaceable>string</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [sindex "Hello, world" 0]
puts [sindex "Hello, world" 11]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>H
d</screen>
      </refsect1>
    </refentry>

    <!-- slen -->
    <refentry id="slen">
      <refnamediv>
	<refname>slen</refname>
	<refpurpose>String length.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>slen</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>slen</command> returns the length of
	  <option><replaceable>string</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [slen "abcdefghijklmnopqrstuvwxyz"]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>26</screen>
      </refsect1>
    </refentry>

     <!-- sort -->
     <refentry id="sort">
      <refnamediv>
	<refname>sort</refname>
	<refpurpose>Sorts list alphabetically.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>sort</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>sort</command> command returns an
	  alphabetically sorted list of the contents of
	  <option><replaceable>list</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [sort {padova rovigo verona vicenza venezia treviso belluno}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>belluno padova rovigo treviso venezia verona vicenza
</screen>
      </refsect1>
    </refentry>

     <!-- source -->
     <refentry id="source">
      <refnamediv>
	<refname>source</refname>
	<refpurpose>Evaluate Hecl script in a file.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>source</command>
	  <arg choice="req"><replaceable>filename</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>source</command> command evaluates the Hecl
	  script located in file
	  <option><replaceable>filename</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
# Variable foo is defined as "Hello world" in foo.hcl
source foo.hcl
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>Hello world</screen>
      </refsect1>
    </refentry>

    <!-- sourcehere - this one is ugly... we need something more
    elegant. -->


    <!-- split -->
    <refentry id="split">
      <refnamediv>
	<refname>split</refname>
	<refpurpose>Split a string into a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>split</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="opt"><replaceable>splitstring</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>split</command> command takes a string and
	  splits it into a list, divided by
	  <option><replaceable>splitstring</replaceable></option>,
	  which defaults to " " if not present.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [split "aaa;bbb;ccc" ";"]
puts [split "aaa bbb ccc"]
puts [split "aaaxbbbycccxyddd" "xy"]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>aaa bbb ccc
aaa bbb ccc
aaaxbbbyccc ddd</screen>
      </refsect1>
    </refentry>

    <!-- time -->
    <refentry id="time">
      <refnamediv>
	<refname>time</refname>
	<refpurpose>Time the execution of a script.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>time</command>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	  <arg choice="opt"><replaceable>repetitions</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>time</command> command executes
	  <option><replaceable>script</replaceable></option>
	  <option><replaceable>repetitions</replaceable></option>
	  times, if
	  <option><replaceable>repetitions</replaceable></option> is
	  present, or once if not.  It measures the amount of time
	  taken by this execution in milliseconds, and returns it.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set time [time {
    set i 0
    while { &lt; &amp;i 100 } {
	incr &amp;i
    }
} 10]
puts "Time is $time"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>Time is 6</screen>
      </refsect1>
    </refentry>

     <!-- true -->
     <refentry id="true">
      <refnamediv>
	<refname>true</refname>
	<refpurpose>Returns true.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>true</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>true</command> command returns 1, or true.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if { true } {
    puts "true is true"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>true is true</screen>
      </refsect1>
    </refentry>

    <!-- upeval -->
    <refentry id="upeval">
      <refnamediv>
	<refname>upeval</refname>
	<refpurpose>Evaluate script in next stack frame up.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>upeval</command>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>upeval</command> command evaluates
	  <option><replaceable>script</replaceable></option> one stack
	  frame up from the current stack frame.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
proc stackframe {} {
    upeval { incr &amp;foo }
}
set foo 1
stackframe
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2</screen>
      </refsect1>
    </refentry>

    <!-- while -->
    <refentry id="while">
      <refnamediv>
	<refname>while</refname>
	<refpurpose>While loop.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>while</command>
	  <arg choice="req"><replaceable>condition</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>while</command> command continues to evaluate
	  <option><replaceable>body</replaceable></option> while
	  <option><replaceable>condition</replaceable></option> is true.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set i 0
while { &lt; &amp;i 6 } {
    puts "i is $i"
    incr &amp;i
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>i is 0
i is 1
i is 2
i is 3
i is 4
i is 5
</screen>
      </refsect1>
    </refentry>

<!--
     <refentry id="append">
      <refnamediv>
	<refname>append</refname>
	<refpurpose>Append text to a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>append</command>
	  <arg choice="req"><replaceable>varreference</replaceable></arg>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The append command takes two arguments, a variable reference, and a string to append to the variable.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo "bar"
append &amp;foo "beebop"
# The foo variable now contains the string barbeebop
	  </programlisting>
	  <para>Produces:</para>
	  <screen>barbeebop</screen>
      </refsect1>
    </refentry>
-->

  </section>


  <section id="heclandjava">
    <title>Interfacing Hecl and Java</title>

    <section>
      <title>Calling Hecl code from Java</title>
      <para>
	Hecl is not a replacement for Java, and is indeed meant to
	work hand in hand with Java.  We attempt to make it as easy as
	possible to call Java from Hecl, via the creation of new Hecl
	commands that can call Java code, in addition to calling Hecl
	from Java, which is a matter of a few lines of code.  For
	example, to evaluate a Hecl file from Java:
      </para>

      <programlisting>
	try {
	    /* First, create a new interpreter, and pass it a
	     * mechanism to load resources with - in this case,
	     * files. */
	    Interp interp = new Interp(new LoadFile());
	    /* Initialize the standard Hecl environment. */
	    com.dedasys.hecl.Standard.init(interp);
	    /* Evaluate the file at args[0] */
	    Eval.eval(interp, interp.getscript(args[0]));
	} catch (Exception e) {
	    System.err.println(e);
	}
      </programlisting>

      <para>
	The above code creates a new interpreter.  Currently,
	interpreters must know about how they are to load files, so the
	interpreter is instantiated with a new
	<classname>LoadFile</classname>, which, as the name suggests,
	contains code to load files from the file system.  Since Hecl is
	also meant for embedded environments, it is also possible to
	create loader classes that load code from a compiled-in string,
	from the network, or whatever other form of storage you may have
	in mind.
      </para>
      <para>
	After creating the interpreter, we call
	<classname>Standard</classname>'s <methodname>init</methodname>
	method.  <classname>Standard</classname> is a class that adds
	several commands that we want to be present in standard J2SE
	Hecl, but not in J2ME Hecl.
      </para>
      <para>
	The real work is done by <methodname>Eval.init</methodname>,
	which takes an interpreter and a Hecl
	<classname>Thing</classname> as arguments.  In this case, the
	<classname>Thing</classname> is the Hecl code read from the disk
	by <classname>LoadFile</classname>.
      </para>
    </section>

    <section>
      <title>Creating new Hecl commands</title>

      <para>
	Creating new Hecl commands is relatively simple.  The first
	step is to create a new class for your command in a file, say
	<filename>HelloCmd.java</filename>.  The code would look
	something like this:
      </para>

      <programlisting>
class HelloCmd implements Command {

    public void cmdCode(Interp interp, Thing[] argv)
	throws HeclException {

	System.out.println("Hello world");
    }
}
      </programlisting>

      <para>
	The command takes an interpreter and an array of
	<classname>Thing</classname>s as arguments, where the first
	<classname>Thing</classname> is the name of the command
	itself, and the others are the arguments to it.
      </para>

      <para>
	The "glue" that connects the name of your Hecl command with
	the Java code is also relatively simple:
      </para>

      <programlisting>
	interp.commands.put("hello", new HelloCmd());
      </programlisting>

      <para>
	Easy, no?  There are a few other useful methods that you
	should be aware of, to share variables between Hecl and Java,
	and to return results from your Hecl commands:
      </para>

      <itemizedlist>
	<listitem>
	  <methodsynopsis>
	    <methodname>interp.setVar</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>varname</parameter>
	    </methodparam>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>value</parameter>
	    </methodparam>
	  </methodsynopsis>
	  This sets the value of <parameter>varname</parameter> to
	  some value.
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>Thing</type>
	    <methodname>interp.getVar</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>varname</parameter>
	    </methodparam>
	  </methodsynopsis>

	  <methodsynopsis>
	    <type>Thing</type>
	    <methodname>interp.getVar</methodname>
	    <methodparam>
	      <type>String</type>
	      <parameter>varname</parameter>
	    </methodparam>
	  </methodsynopsis>
	  These methods take a variable name, either in string form or
	  as a <classname>Thing</classname>, and return the
	  <classname>Thing</classname> associated with that variable.
	</listitem>

	<listitem>
	  <para><varname>interp.result</varname> is used to set the
	    result of a command.  This oft-used variable is accessed
	    directly for simplicity, speed and smaller code size.
	  </para>
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>int</type>
	    <methodname>IntThing.get</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>thing</parameter>
	    </methodparam>
	  </methodsynopsis>
	  Get an int from a Thing.
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>String</type>
	    <methodname>StringThing.get</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>thing</parameter>
	    </methodparam>
	  </methodsynopsis>
	  Get a String from a Thing.
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>Thing</type>
	    <methodname>IntThing.create</methodname>
	    <methodparam>
	      <type>int</type>
	      <parameter>i</parameter>
	    </methodparam>
	  </methodsynopsis>
	  Creates a new thing from an int.
	</listitem>

      </itemizedlist>

    </section>

    <section>
      <title>JavaDocs</title>

      <para>
	For the complete Hecl javadoc documentation, see the <ulink
	  url="jdocs">Hecl Javadocs</ulink>.  And, of course, look at
	  the Hecl source code to see how it's done!
      </para>

    </section>

  </section>


  <section id="j2me">
    <title>Hecl and J2ME</title>

    <para>
      Hecl is designed to be small enough to run on mobile devices
      such as cell phones.  This means that it has been necessary to
      limit ourselves to Java API's that work with J2ME.
    </para>

    <para>FIXME - more later.</para>

  </section>

</article>
