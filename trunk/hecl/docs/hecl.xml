<?xml version="1.0" encoding="iso-8859-1"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
  "http://www.oasis-open.org/committees/docbook/xml/4.1.2/docbookx.dtd"
  [
      <!ENTITY reverse.hcl SYSTEM "reverse.hcl" >
]>

<!--
   Copyright 2004-2007 David N. Welton

   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License.  You
   may obtain a copy of the License at

   	http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied.  See the License for the specific language governing
   permissions and limitations under the License.
-->

<!-- $Id$ -->

<article>
  <articleinfo>
    <title>
      <ulink url="http://www.hecl.org/">
	Hecl Programming Language
      </ulink>
    </title>
    <copyright>
      <year>2004</year>
      <year>2005</year>
      <year>2006</year>
      <year>2007</year>
      <holder>
	David N. Welton
      </holder>
    </copyright>
    <author>
      <firstname>David</firstname>
      <surname>Welton</surname>
      <affiliation>
	<orgname>hecl.org</orgname>
	<address>
	  <email>hecl-devel@lists.sourceforge.net</email>
	</address>
      </affiliation>
    </author>
  </articleinfo>

  <section>
    <title>Introduction</title>
    <para>
      The Hecl Programming Language is a high-level scripting language
      implemented in Java.  It is intended to be small, extensible,
      extremely flexible, and easy to learn and use.
    </para>

    <para>
      Why Hecl?  Hecl is intended as a complement to the Java
      programming language, not a replacement.  It tries to do well
      what Java doesn't, and leaves those tasks to Java for which it
      is best suited, by providing an API that makes it easy to tie
      the two together.  Hecl aims to be a very immediate language -
      you can pick it up and start doing useful things with it quickly
      - even people without formal training.  Hecl is easy to learn.
      Where Java is verbose and rigid, Hecl is forgiving and quick to
      write.  For instance,
      <userinput>System.out.println("Hello World");</userinput>
      vs <userinput>puts "Hello World"</userinput> - 41
      keystrokes (shifted letters count double) versus 22.  Hecl is
      built to <ulink
      url="http://www.dedasys.com/articles/scalable_systems.html">"scale
      down"</ulink> - especially in terms of its users, meaning that
      it is very quick to learn, and can be quickly put to productive
      use even by those who are not programmers by trade.
    </para>

    <para>
      This makes Hecl ideal for large applications written in Java
      that would like to provide a user friendly scripting interface,
      rather than, say, a clunky XML based system.  Examples include:
      scripted web pages, command/control logic in long running
      applications, and, I'm sure, many environments I've never
      considered.  Instead of a simple, static configuration file, you
      can give your users the power to program portions of the system
      to do things that you hadn't thought of when you wrote the
      software originally.
    </para>

    <para>
      Hecl is a small language with a minimal core.  The idea is to
      provide only what's necessary in the language itself, and as
      needed, add in extensions for specific tasks.  Core Hecl is
      small enough to run on my Nokia 3100 cell phone as a J2ME
      application, presenting the interesting possibility of writing
      scripts, or at some point, maybe even scripting entire
      applications, for devices running embedded Java.
    </para>

    <para>
      Contributions in the form of code, ideas, suggestions, or even
      donations are welcome.  Hecl is still growing, so your thoughts
      are important, and you can help shape the language's future.
      You can download the latest code via Subversion from the
      SourceForge project page: <ulink
      url="http://sourceforge.net/projects/hecl/">http://sourceforge.net/projects/hecl/</ulink>.
    </para>

    <para>
      Hecl is available under the liberal Apache 2.0 open source
      license.  Which says, more or less, that you may use Hecl in
      your own applications, even if they are not open source.  You
      have to give the authors credit, though.  Read the license
      itself to clear up any doubts.  Incidentally, I don't see the
      license as being incompatible with the GPL, so feel free to
      utilize Hecl in your GPL product (I have added a note to this
      effect in the NOTICE file that must accompany products using the
      Hecl code).
    </para>

    <para>
      I owe thanks to a lot of people for Hecl.  First and foremost
      the creator of the Tcl programming language, Dr. John
      Ousterhout.  While I have attempted to improve some things that
      I did not care for in Tcl, it is obvious that the simple,
      extremely flexible command-based approach that Hecl takes is
      derived from Tcl.  I also borrowed some ideas from the (mostly
      defunct) Jacl implementation of Tcl in Java.  Many thanks are
      also due my friend Salvatore Sanfilippo, with whom I have spent
      many hours discussing Hecl, Tcl, and the philosophy of
      programming languages in general.  And of course, I owe a huge
      debt of gratitude to my wife, Ilenia, who puts up with all the
      hours I spend in front of "that damn computer".
    </para>

  </section>

  <section id="installation">
    <title>Installation</title>
    <para>
      Hecl is easy to compile and install as a standard J2SE
      application.  This is only necessary if you'd like to work on
      Hecl.  If all you want to do is use it, or install it on your
      mobile phone, these steps aren't necessary - the standard
      distribution contains everything you need.
    </para>
    <para>
      <note>
	On Microsoft Windows, you must add your java bin directory to
	the system path, otherwise you will get strange, seemingly
	unrelated errors!
      </note>
    </para>
    <procedure>
      <step>
	Hecl uses the <link url="http://ant.apache.org/">Apache
	Ant</link> build system, so you need to install that to
	compile Hecl.
      </step>
      <step>
	To compile the standard, J2SE version of Hecl, do this:
	<screen>
ant packageCommandline
</screen>
      </step>
      <step>
	<para>
	  You should now have a Hecl.jar file in the
	  <filename>jars/j2se/</filename> directory.  To run it, do
	  this:
	</para>
	<screen>
java -jar jars/j2se/Hecl.jar Hecl
hecl> puts "hello world"
hello world
</screen>
      </step>
      <step>
	If you wish, you can compile Hecl to native code with GCJ:
	<screen>
gcj -o hecl --main=Hecl jars/j2se/Hecl.jar
davidw@medford:~/workshop/hecl$ ./hecl
hecl> puts "hello world"
hello world
	</screen>
      </step>
      <step>
	If you want to check your installation of Hecl, you can run
	the test suite to make sure everything checks out:
	<screen>
java -classpath jars/j2se/Hecl.jar Hecl tests/suite.hcl
	</screen>
	An (incomplete) performance test is also supplied so that you
	can compare numbers if you're curious, or want to hack on Hecl
	to improve its speed:
	<screen>
java -classpath jars/j2se/Hecl.jar Hecl tests/performance.hcl
	</screen>
      </step>
    </procedure>


    <para>
      See <xref linkend="j2me"/> for more information on installation
      and use with J2ME.
    </para>

  </section>

  <section id="tutorial">
    <title>Hecl Tutorial</title>
    <para>
      Like many people, I enjoy taking something and experimenting
      with it before going and reading the instructions!  With this in
      mind, I have written a brief tutorial that you can use to start
      exploring Hecl on your own.
    </para>

    <para>
      Of course, we would be out of place not to begin with the famous
      "Hello, World".  Behold:
    </para>
    <programlisting>puts "Hello, World"</programlisting>
    <para>
      Hecl is based on the notion of commands, which take any number
      of arguments.  The <command>puts</command> command takes one
      argument, a string, and prints it out.
    </para>
    <para>
      Like all programming languages, Hecl provides variables that may
      be used to store information. Here, we set a variable,
      <varname>rating</varname>, and then print it out in the midst of
      a string.  This is called "interpolation", and is a convenient
      way of creating new strings.
    </para>
	    <programlisting>set rating 10
puts "Hecl, from 1 to 10: $rating"</programlisting>
    <para>
      Something else we notice in the above examples is that we use
      double quotes "" to group a series of things.  In Hecl, commands
      and their arguments are separated by spaces.  Since
      <command>puts</command> only takes one argument, a string, we
      use the quotes to group several words together in order to pass
      them as one string to the command.  Many languages require
      quotes to delineate a string, but in Hecl that is not necessary
      if the string has no spaces in it.  For instance,
      <userinput>puts helloworld</userinput> is legitimate.
    </para>

    <para>
      Another way of grouping multiple words in Hecl is with braces:
      {}.  Hecl does not automatically perform any substitution on the
      variables or commands grouped within braces, as it does with
      quotes.
    </para>

    <programlisting>puts {The $dollar $signs $are printed	    literally$$ - no substitution}</programlisting>

    <para>
      Aside from the dollar sign, which returns a reference to the
      value of a variable, it is also possible to utilize the results
      of one command as the input of a second command.  For example:
    </para>

    <programlisting>set rating 10
puts "Rating:"
puts [set rating]</programlisting>

    <para>
      In this case, we pass the results of the <command>set</command>
      command to the <command>puts</command> command.  In reality, <userinput>set
	rating</userinput> is just a long way of writing
      <option>$rating</option> but it's a good example.
    </para>

    <para>
      Like everything else in Hecl, we perform math operations as
      commands:
    </para>

    <programlisting>puts "2 + 2 = [+ 2 2]"</programlisting>

    <para>
      In the example, the <command>+</command> takes two arguments,
      adds them together and return the result, which is then printed
      out by the <command>puts </command> command.
    </para>

    <para>
      In order to choose between one or more 
    </para>

    <programlisting>set temp 10
if { &lt; $temp 0 } {
    puts "It's freezing"
} else {
    puts "Not freezing"
}</programlisting>

    <para>References:</para>

    <programlisting>set a 1
set b $a
puts $b
# Prints '1'
set a 2
puts $b
# Prints '2'</programlisting>

    <para>"while" loop command:</para>

    <programlisting>set i 0
while { &lt; $i 10 } {
    puts "i is now $i"
    incr $i
}
</programlisting>

    <para>Lists:</para>

    <programlisting>set foo [list a b c]
set bar {a b c}
lappend $foo d
lappend $bar d
set foo
# Returns 'a b c d'
set bar
# Returns 'a b c d'
</programlisting>

    <para>Hash tables:</para>

    <programlisting>set foo [hash {a b c d}]
puts [hget $foo a]
# prints 'b'
puts [hget $foo c]
# prints 'd'
hset $foo c 2
puts [hget $foo c]
# prints '2'
puts $foo
# prints 'a b c 2' (although not necessarily in that order)
</programlisting>

    <para>"foreach" loop command:</para>

    <programlisting>set lst {a b c d e f}
foreach {m n} $lst {
    puts  "It is possible to grab two variables at a time: $m $n"
}

foreach {x} $lst {
    puts  "Or one at a time: $x"
}</programlisting>

    <para>
      Create new commands with the "proc" command.  In this example we
      create a command that prints out a numbered list.
    </para>

    <programlisting>set list {red blue green}
proc printvals {vals} {
    set num 1
    foreach v $vals {
	puts "$num - $v"
	incr $num
    }
}

printvals $list</programlisting>

    <para>
      Hecl is very flexible - in this example, we create a
      "do...while" loop command that works as if it were a native loop
      construct.
    </para>

    <programlisting>proc do {code while condition} {
    upeval $code
    while { upeval $condition } {
	upeval $code
    }
}

set x 100
set foo ""
do {
    append $foo $x
    incr $x
} while { &lt; $x 10 }
set foo
# Returns 100 - because the loop is run once and only once.
</programlisting>

  </section>

  <section id="commands">
    <title>Hecl Commands</title>

    <para>
      These commands are part of the Hecl core and are always present.
    </para>

    <!-- = -->
    <refentry id="equality">
      <refnamediv>
	<refname>= !=</refname> <refpurpose>Integer
	equality</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>=</command>
	  <arg choice="req"><replaceable>num1</replaceable></arg>
	  <arg choice="req"><replaceable>num2</replaceable></arg>
	  <command>!=</command>
	  <arg choice="req"><replaceable>num1</replaceable></arg>
	  <arg choice="req"><replaceable>num2</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title> <para>Tests two numbers for
	equality, returning 1 if they are, 0 if they aren't equal.  In
	the case of <command>!=</command>, returns 1 if they are not
	equal, 0 if they are equal.</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
puts [= 1 1]
puts [= 0 1]
puts [= 00001 1]
puts [!= 1 1]
	</programlisting>
	<para>Produces:</para>
	<screen>
1
0
1
0
	</screen>
      </refsect1>
    </refentry>


    <!-- + - * / math commands -->
    <refentry id="math">
      <refnamediv>
	<refname>+ - * /</refname>
	<refpurpose>Basic math commands.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>+</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="opt" rep="repeat"><replaceable>number</replaceable></arg>
	  <command>-</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <command>*</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <command>/</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The basic math commands take two arguments and carry out a
	  numerical operation on them.  In subtraction, the second
	  argument is taken from the first.  In division, the first
	  argument is divided by the second.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [+ 2 2]
puts [+ 1 2 3]
puts [- 10 1]
puts [* 6 7]
puts [/ 100 5]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4
6
9
42
20</screen>
      </refsect1>
    </refentry>

    <refentry id="fpmath">
      <refnamediv>
	<refname>abs acos acos asin asin atan atan cbrt ceil cos cosh
cosh exp expm1 floor hypot log log10 log1p pow random round signum sin
sinh sqrt tan tanh tanh</refname>
	<refpurpose>Floating point math commands</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command><replaceable>command</replaceable></command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  Floating point math commands.  The names are mostly self
	  explanatory, corresponding to the methods found here: <ulink
	  url="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Math.html">http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Math.html</ulink>
	</para>
	<note>
	  Keep in mind that none of these commands are available in
	  the MIDP1.0 version of Hecl, and that the following commands
	  are available only in J2SE versions of Hecl:
	</note>
	<para>
	  <command>acos</command> <command>atan</command>
	  <command>ceil</command> <command>round</command>
	  <command>exp</command> <command>floor</command>
	  <command>random</command> <command>pow</command>
	  <command>sin</command> <command>cos</command>
	  <command>sqrt</command> <command>log</command>
	  <command>tan</command> <command>asin</command>
	</para>
	<para>The following are only available in versions of Hecl
	built with Java 1.5 and above.</para>
	<para>
	  <command>cbrt</command> <command>cosh</command>
	  <command>expm1</command> <command>hypot</command>
	  <command>log10</command> <command>log1p</command>
	  <command>signum</command> <command>sinh</command>
	  <command>tanh</command>
	</para>
      </refsect1>
    </refentry>

    <!-- after -->
    <refentry id="after">
      <refnamediv>
	<refname>after</refname>
	<refpurpose>Sleep / delayed script evaluation</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>after</command>

	  <group choice="req">
	    <arg choice="plain">
	      <replaceable>milliseconds</replaceable>
	      <arg><replaceable>script</replaceable></arg>
	    </arg>

	    <arg choice="plain">
	      info
	      <arg choice="opt"><replaceable>event</replaceable></arg>
	    </arg>

	    <arg choice="plain">
	      cancel
	      <arg choice="req"><replaceable>event</replaceable></arg>
	      <arg choice="opt" rep="repeat"><replaceable>event</replaceable></arg>
	    </arg>

	    <arg choice="plain">
	      idle
	      <arg><replaceable>script</replaceable></arg>
	    </arg>

	  </group>

	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>after</command> command is used, in the simple
	  case, to simply halt evaluation of the script for
	  <option><replaceable>milliseconds</replaceable></option>
	  milliseconds, or execute a script after that number of
	  milliseconds.
	</para>
	<para>
	  The after command can also be used to manage timer events in
	  Hecl via the <command>info</command> and
	  <command>cancel</command> subcommands, which, respectively,
	  return information about existing events, and allow the
	  cancellation of events.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<para>Pause for 1 second:</para>

	  <programlisting>after 1000</programlisting>

	<para>
	  Run <option><replaceable>script</replaceable></option> after
	  10 seconds, but do not pause execution of the main script:
	</para>

	<programlisting>after 10000 { puts "hello, later world"	}</programlisting>

	<para>Cancel all timers:</para>

	<programlisting>for {set i 1} {&lt; $i 11} {incr $i} {
    puts [after [* 10000 [random]] [list puts "Event number $i"]]
}

after 5000

foreach e [after info] {
    after cancel $e
    puts "Event $e cancelled"
}

twait forever</programlisting>
	<para>Will produce, on average, something like the
	following:</para>
	<screen>timer#1
timer#2
timer#3
timer#4
timer#5
timer#6
timer#7
timer#8
timer#9
timer#10
Event number 9
Event number 4
Event number 10
Event timer#5 cancelled
Event timer#1 cancelled
Event timer#7 cancelled
Event timer#3 cancelled
Event timer#2 cancelled
Event timer#6 cancelled
Event timer#8 cancelled
	</screen>

      </refsect1>
    </refentry>


    <!-- and -->
    <refentry id="and">
      <refnamediv>
	<refname>and</refname>
	<refpurpose>Logical and</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>and</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>...</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>and</command> command takes one or more
	  arguments, and performs a binary and on them, in sequence.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
hecl> and 1 0
0
hecl> and 1 1
1
hecl> and 1
1
hecl> and 2 4
0
hecl> and 5 1
1
hecl> and 5 4
4
hecl> and 1 2 4 8
0
	</programlisting>
      </refsect1>
    </refentry>


    <!-- append -->
    <refentry id="append">
      <refnamediv>
	<refname>append</refname>
	<refpurpose>Append text to a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>append</command>
	  <arg choice="req"><replaceable>varreference</replaceable></arg>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The append command takes two arguments, a variable reference, and a string to append to the variable.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo "bar"
append $foo "beebop"
# The foo variable now contains the string barbeebop
	  </programlisting>
	  <para>Produces:</para>
	  <screen>barbeebop</screen>
      </refsect1>
    </refentry>

    <!-- break -->
    <refentry id="break">
      <refnamediv>
	<refname>break</refname>
	<refpurpose>Break out of a loop.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>break</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The break command breaks out of a loop.  If this command is
	  not run from within a loop - the <command>while</command> or
	  <command>foreach</command> commands for instance, it
	  generates an error.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set i 0
while { true } {
    if { > $i 100 } {
        break
    }
    incr $i
}
	  </programlisting>
	<para>
	  In what would otherwise be an endless loop, the break
	  command is used to exit.
	</para>
      </refsect1>
    </refentry>

    <refentry id="bgerror">
      <refnamediv>
       <refname>bgerror</refname>
       <refpurpose>Called for background task errors.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
       <cmdsynopsis>
         <command>append</command>
         <arg choice="req"><replaceable>message</replaceable></arg>
       </cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
       <title>Description</title>
       <para>
         Hecl calls <command>bgerror</command> when there is a
         problem in a background task (created with the
         <command>after</command> command, for instance).
       </para>
      </refsect1>
      <refsect1>
       <title>Example</title>
         <programlisting>
hecl> proc bgerror {msg} { puts "Houston, we have a problem: $msg" }
hecl> after 1 { beebop }
timer#7
         </programlisting>
         <para>Produces:</para>
         <screen>Houston, we have a problem: Command beebop does not exist</screen>
      </refsect1>
    </refentry>


    <!-- catch -->
    <refentry id="catch">
      <refnamediv>
	<refname>catch</refname>
	<refpurpose>
	  Evaluates a script, catching any errors.
	</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>catch</command>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	  <arg choice="opt"><replaceable>varname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The catch command evaluates a script, and returns 0 if the
	  script evaluated successfully.  If there were errors, catch
	  returns 1.  Optionally, a variable name may be passed to the
	  command, where the results of the script evaluation will be
	  placed.  In the case of errors, the stack trace will be
	  placed in the variable argument.  If the script executes
	  without problems, the variable will contain the result of
	  the script execution.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
catch nosuchcommand foo
set foo
	  </programlisting>
	  <para>Produces:</para>
	<screen>
	  {ERROR {Command nosuchcommand does not exist}}
	</screen>
      </refsect1>
    </refentry>

    <!-- classof -->
    <refentry id="classof">
      <refnamediv>
	<refname>classof</refname>
	<refpurpose>
	  Returns the name of the internal class of a Hecl Thing.
	</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>classof</command>
	  <arg choice="req"><replaceable>variable</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The classof command returns a string containing the Java
	  name of the class that the Hecl variable contains
	  internally.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
classof [+ 1 2]

classof "foo"
	  </programlisting>
	  <para>Produces:</para>
	<screen>
org.hecl.IntThing

org.hecl.StringThing
	</screen>
      </refsect1>
    </refentry>

    <refentry id="clock">
      <refnamediv>
	<refname>clock</refname>
	<refpurpose>Provides time utilities</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>clock</command>
	  <group>
	    <arg choice="req">seconds</arg>
	    <arg choice="req">time</arg>
	    <arg choice="req">format <replaceable>format</replaceable></arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>The <command>clock</command> command is used to return
	  information on the current time.  With the
	<option>seconds</option> option, the number of seconds since
	  January 1st, 1970 are returned.  With the
	<option>time</option> option, milliseconds since that date are
	returned.
	</para>
	<para>With the <option>format</option> option, the
	<command>clock</command> command takes a millisecond value and
	returns a formatted date and time.  For example:
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<screen>
hecl&gt; clock format [clock time]
Fri Jun 15 13:22:20 CEST 2007
	</screen>
      </refsect1>

    </refentry>

    <!-- continue -->
    <refentry id="continue">
      <refnamediv>
	<refname>continue</refname>
	<refpurpose>Skip to next cycle of a loop</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>continue</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The continue command is used within the bodies of looping
	  commands such as <command>if</command> and
	  <command>while</command>.  When <command>continue</command>
	  is called, execution of the loop body stops and and
	  execution moves on to the next iteration of the loop.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
set i 0
set res {}
foreach x {a b c d e} {
    incr $i
    continue
    append $res $x
}
puts $i
puts $res
	</programlisting>
	<para>Produces:</para>
	<screen>5</screen>
	<para>
	  The res variable is never appended to, so printing it out
	  produces an empty string.
	</para>
      </refsect1>
    </refentry>

    <refentry id="double">
      <refnamediv>
	<refname>double</refname>
	<refpurpose>Cast as a double</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>double</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>When given a number
	  <option><replaceable>number</replaceable></option>, return
	its value cast as a double.
	</para>
	<important>
	  This command does not appear in the MIDP1.0 version of Hecl,
	  because it doesn't deal with floating point.
	</important>
      </refsect1>
    </refentry>

    <!-- eq -->
    <refentry id="eq">
      <refnamediv>
	<refname>eq</refname>
	<refpurpose>Tests string equivalence.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>eq</command>
	  <arg choice="req"><replaceable>string1</replaceable></arg>
	  <arg choice="req"><replaceable>string2</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>eq</command> commands compares two strings,
	  returning 1 if they are equal, 0 if they are not.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if {eq 1 1.0} {
    puts "True"
} else {
    puts "False"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>False</screen>

	<para>
	  Despite being numerically equivalent, the strings "1" and
	  "1.0" are different.
	</para>
      </refsect1>
    </refentry>

    <refentry id="eval">
      <refnamediv>
	<refname>eval</refname>
	<refpurpose>Evaluate Hecl code.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>eval</command>
	  <arg choice="req"><replaceable>code</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>eval</command> command takes a string
	  containing Hecl commands, evaluates them, and returns the
	  result.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set i 0
set str {incr}
lappend $str "i"
eval $str
puts $i
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1</screen>
      </refsect1>
    </refentry>

    <refentry id="exit">
      <refnamediv>
	<refname>exit</refname>
	<refpurpose>Exit the current process</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>exit</command>
	  <arg choice="opt"><replaceable>exitcode</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>exit</command> command stops the execution of
	  the current process.  It causes the
	  <option><replaceable>exitcode</replaceable></option> (an
	  integer) to be returned by the process.
	</para>
      </refsect1>
    </refentry>

    <refentry id="false">
      <refnamediv>
	<refname>false</refname>
	<refpurpose>Return false</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>false</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>false</command> command is the opposite of
	  <command>true</command>, and always returns a false value.
	</para>
      </refsect1>
    </refentry>

    <refentry id="filter">
      <refnamediv>
	<refname>filter</refname>
	<refpurpose>Filter a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>filter</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>filter</command> command takes a list and
	  filters it according to the code provided in
	  <option><replaceable>code</replaceable></option>.  The
	  current element of the list being considered is stored in
	  the <option><replaceable>varname</replaceable></option>
	  provided.  A list of 'matches' is returned.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set lst {1 2 3 4 5 4 3 2 1}
puts [filter $lst x {= $x 4}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4 4</screen>
      </refsect1>
    </refentry>

    <refentry id="float">
      <refnamediv>
	<refname>float</refname>
	<refpurpose>Cast as a float</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>float</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>When given a number
	  <option><replaceable>number</replaceable></option>, return
	its value cast as a float.
	</para>
	<important>
	  This command does not appear in the MIDP1.0 version of Hecl,
	  because it doesn't deal with floating point.
	</important>
      </refsect1>
    </refentry>

    <refentry id="for">
      <refnamediv>
	<refname>for</refname>
	<refpurpose>For loop.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>for</command>
	  <arg choice="req"><replaceable>initialization</replaceable></arg>
	  <arg choice="req"><replaceable>test</replaceable></arg>
	  <arg choice="req"><replaceable>step</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>for</command> command is like in many other
	  languages like C and Java.  As arguments, it takes an
	  <option><replaceable>initialization</replaceable></option>
	  option, which is often used to set a variable to some
	  initial value, a
	  <option><replaceable>test</replaceable></option> to
	  determine whether to continue running, a
	  <option><replaceable>step</replaceable></option> script
	  option which is run at each iteration of the body (to
	  increment a variable, for example), and the body itself.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set out {}
for {set i 0} {&lt; $i 10} {incr $i} {
    append $out $i
}
puts $out
	  </programlisting>
	  <para>Produces:</para>
	  <screen>0123456789</screen>
      </refsect1>
    </refentry>

    <refentry id="foreach">
      <refnamediv>
	<refname>foreach</refname>
	<refpurpose>Iterate over elements in a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>foreach</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	  <command>foreach</command>
	  <arg choice="req"><replaceable>varlist</replaceable></arg>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The foreach command iterates over a list.  For each element
	  of the list,
	  <option><replaceable>varname</replaceable></option> is set
	  to a new element of the list, and then
	  <option><replaceable>body</replaceable></option> is run.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set lst {a b c d e}
set res {}
foreach el $lst {
    append $res $el
}
puts $res
	  </programlisting>
	  <para>Produces:</para>
	  <screen>abcde</screen>
      </refsect1>
    </refentry>

    <!-- global -->
    <refentry id="global">
      <refnamediv>
	<refname>global</refname>
	<refpurpose>Use global variable from within a proc.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>global</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="opt" rep="repeat"><replaceable>varname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  By default, Hecl variables are always local.  Global
	  variables are not visible from within procedures.  The
	  <command>global</command> command makes global variable
	  <option><replaceable>varname</replaceable></option> visible
	  within a procedure.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo 1
proc incfoo {} {
    global foo
    incr $foo
}
incfoo
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2</screen>
      </refsect1>
    </refentry>

    <refentry id="hasclass">
      <refnamediv>
	<refname>hasclass</refname>
	<refpurpose>An interface to <methodname>Class.forName</methodname></refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>hasclass</command>
	  <arg choice="req"><replaceable>classname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  Reports whether a given class is present or not.
	</para>
	<important>
	  Keep in mind that in J2ME, using an obfuscator, class names
	  may not be what you think they are!  Only use this for
	  system-defined classes.
	</important>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<screen>
hecl> hasclass org.hecl.net.HttpCmd
1
hecl> hasclass oogyboogy
0
	</screen>
      </refsect1>
    </refentry>

    <!-- hash, hget, hset -->
    <refentry id="hash">
      <refnamediv>
	<refname>hash</refname>
	<refpurpose>Create and manipulate hash tables.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>hash</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <command>hget</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	  <command>hset</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	  <arg choice="req"><replaceable>value</replaceable></arg>
	  <command>hcontains</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	  <command>hclear</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <command>hkeys</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <command>hremove</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>hash</command> command takes an even-numbered
	  list and creates a hash table from it, using the even
	  elements as keys, and odd elements as values.  A new hash
	  table is returned.  The <command>hget</command> and
	  <command>hset</command> commands operate on hash tables.
	  Both take a hash table as their first argument.
	  <command>hget</command> also takes a key, and returns the
	  corresponding value, or an error if no key by that name
	  exists.  To determine whether a given key exists, use the
	  <command>hcontains</command> command, which returns true or
	  false depending on whether the key exists in the hash table.
	</para>
	<para>
	  The
	  <command>hkeys</command> command returns the keys of the
	  hash table, as a list.
	</para>
	<para>
	  The <command>hclear</command> command clears an entire hash
	  table, whereas <command>hremove</command> removes the value
	  associated with a given key.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo [hash {a b c d}]
hset $foo a 42
puts [hget $foo a]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>42</screen>
      </refsect1>
    </refentry>

    <!-- if -->
    <refentry id="if">
      <refnamediv>
	<refname>if</refname>
	<refpurpose>Conditionally execute code.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>if</command>
	  <arg choice="req"><replaceable>test</replaceable></arg>
	  <arg choice="req"><replaceable>code</replaceable></arg>
	  <group choice="opt" rep="repeat">
	    <arg choice="req"><option>elseif</option></arg>
	    <arg choice="req"><replaceable>test</replaceable></arg>
	    <arg choice="req"><replaceable>code</replaceable></arg>
	  </group>
	  <group choice="opt">
	    <arg choice="req"><option>else</option></arg>
	    <arg choice="req"><replaceable>code</replaceable></arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The if command executes Hecl code conditionally.  In its
	  most basic form, it executes a
	  <option><replaceable>test</replaceable></option>.  If the
	  results are not 0, then it executes
	  <option><replaceable>code</replaceable></option>.  If not,
	  no further actions take place.  <command>if</command> may
	  take any number of <option>elseif</option> clauses, which
	  have their own
	  <option><replaceable>test</replaceable></option> and
	  <option><replaceable>code</replaceable></option>.  Finally,
	  if none of the conditions has matched, it is also possible
	  to supply an <option>else</option> clause that will be
	  executed if the results of the if and elseif tests were all
	  false.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if { true } {
    puts "true"
} else {
    puts "false"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>true</screen>
	  <programlisting>
if { > 0 1 } {
    puts "true"
} else {
    puts "false"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>false</screen>
      </refsect1>
    </refentry>

    <!-- incr -->
    <refentry id="incr">
      <refnamediv>
	<refname>incr</refname>
	<refpurpose>Increment a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>incr</command>
	  <arg choice="req"><replaceable>varreference</replaceable></arg>
	  <arg choice="req"><replaceable>integer</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>incr</command> command takes a variable
	  reference, and adds <option><replaceable>integer to
	  it</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo 1
incr $foo
puts "foo is $foo"
incr $foo 10
puts "foo is now $foo"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2
12</screen>
      </refsect1>
    </refentry>

    <!-- intro -->
     <refentry id="intro">
      <refnamediv>
	<refname>intro</refname>
	<refpurpose>Introspection command.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>intro</command>
	  <group>
	    <arg choice="req">commands</arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>intro</command> command is used for Hecl
	  introspection.  It takes a subcommand which causes it to
	  perform the desired function.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
 puts [sort [intro commands]]
	  </programlisting>
	  <para>Produces: (depending on the available commands)</para>
	  <screen>* + - / &lt; = &gt; append break catch continue copy eq eval filter for foreach global hash hget hset if incr intro join lappend lindex list llen lset proc puts ref return search set strindex strlen sort source split time true upeval while</screen>
      </refsect1>
    </refentry>

    <!-- join -->
     <refentry id="join">
      <refnamediv>
	<refname>join</refname>
	<refpurpose>Join elements of a list to create a string.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>join</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="opt"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>join</command> command takes a
	  <option><replaceable>list</replaceable></option> argument,
	  and optionally, a
	  <option><replaceable>string</replaceable></option>
	  argument.  It joins all elements of the list together with
	  the string, or, if a string is not provided, with a space.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [join {a b c} "|"]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a|b|c</screen>
      </refsect1>
    </refentry>

    <!-- lappend -->
     <refentry id="lappend">
      <refnamediv>
	<refname>lappend</refname>
	<refpurpose>Append an element to a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lappend</command>
	  <arg choice="req"><replaceable>listreference</replaceable></arg>
	  <arg choice="req"><replaceable>element</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lappend</command> takes a reference to a list,
	  and an element to add to that list.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo a
lappend $foo "b"
puts $foo
lappend $foo "c d"
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a b
a b {c d}</screen>
      </refsect1>
    </refentry>

    <!-- lindex -->
    <refentry id="lindex">
      <refnamediv>
	<refname>lindex</refname>
	<refpurpose>Return the Nth element of a list</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lindex</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>index</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lindex</command> command takes a list and an
	  index number as arguments, and return's the index'th element
	  of the list.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
puts [lindex {a b c} 2]
	</programlisting>
	<para>Produces:</para>
	<screen>c</screen>
      </refsect1>
    </refentry>


    <!-- list -->
     <refentry id="list">
      <refnamediv>
	<refname>list</refname>
	<refpurpose>Create a list</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>list</command>
	  <arg choice="req"><replaceable>element</replaceable></arg>
	  <group choice="opt" rep="repeat">
	    <arg choice="req"><replaceable>element</replaceable></arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>list</command> command takes any number of
	  arguments and returns a list.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
puts [list a b c [list 1 2 3]]
	</programlisting>
	<para>Produces:</para>
	<screen>a b c {1 2 3}</screen>
      </refsect1>
    </refentry>

    <!-- llen -->
     <refentry id="llen">
      <refnamediv>
	<refname>llen</refname>
	<refpurpose>List length.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>llen</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>llen</command> returns the length of its list
	  argument.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [llen {1 2 3 {a b c}}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4</screen>
      </refsect1>
    </refentry>

    <!-- lrange -->
    <refentry id="lrange">
      <refnamediv>
	<refname>lrange</refname>
	<refpurpose>Get range of elements from a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lrange</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>first</replaceable></arg>
	  <arg choice="req"><replaceable>last</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lrange</command> command fetches a range of
	  elements from
	  <option><replaceable>list</replaceable></option>, starting
	  at element <option><replaceable>first</replaceable></option>
	  and ending at <option><replaceable>first</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
lrange {a b c d e f g} 0 2
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a b c</screen>
      </refsect1>
    </refentry>

    <!-- lset -->
    <refentry id="lset">
      <refnamediv>
	<refname>lset</refname>
	<refpurpose>Set list elements.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lset</command>
	  <arg choice="req"><replaceable>listref</replaceable></arg>
	  <arg choice="req"><replaceable>index</replaceable></arg>
	  <arg choice="opt"><replaceable>replacement</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lset</command> command sets the
	  <option><replaceable>index</replaceable></option>'th element
	  of the list to
	  <option><replaceable>replacement</replaceable></option>.  If
	  <option><replaceable>replacement</replaceable></option> is
	  not present, then the element is deleted.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
    set lst {a b c}
    lset $lst 1 x
    puts $lst

    lset $lst 1
    puts $lst
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a x c
a c</screen>
      </refsect1>
    </refentry>

    <!-- ne -->
    <refentry id="ne">
      <refnamediv>
	<refname>ne</refname>
	<refpurpose>String "not equal".</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>ne</command>
	  <arg choice="req"><replaceable>string1</replaceable></arg>
	  <arg choice="req"><replaceable>string2</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>ne</command> commands compares two strings,
	  returning 0 if they are equal, 1 if they are not.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if {ne 1 00001} {
    puts "True"
} else {
    puts "False"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>True</screen>
      </refsect1>
    </refentry>

    <!-- not -->
    <refentry id="not">
      <refnamediv>
	<refname>not</refname>
	<refpurpose>Logical not</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>not</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>not</command> command performs a logical not on
	  the argument given to it.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
hecl> not 0
1
hecl> not 1
0
hecl> not 4
0
	</programlisting>
      </refsect1>
    </refentry>

    <!-- or -->
    <refentry id="or">
      <refnamediv>
	<refname>or</refname>
	<refpurpose>Logical or</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>or</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>...</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>or</command> command does a binary or of the
	  numbers passed to it, so it can also be used as a logical
	  or.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
hecl> or 1
1
hecl> or 0
0
hecl> or 1 0
1
hecl> or 2 4
6
hecl> or 1 2 4
7
	</programlisting>
      </refsect1>
    </refentry>


    <!-- proc -->
    <refentry id="proc">
      <refnamediv>
	<refname>proc</refname>
	<refpurpose>Create a new procedure.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>proc</command>
	  <arg choice="req"><replaceable>name</replaceable></arg>
	  <arg choice="req"><replaceable>arglist</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>proc</command> command creates new procedures,
	  which are virtually indistinguishable from built-in Hecl
	  commands.  <option><replaceable>name</replaceable></option>
	  is the name of the new command,
	  <option><replaceable>arglist</replaceable></option> is a
	  list of arguments that the new command will take and make
	  available as local variables within the
	  <option><replaceable>body</replaceable></option>, which is
	  the code executed every time the command is called.  If the
	  last element of the argument list is
	  <important>args</important>, the variable
	  <varname>args</varname> is a list that is filled with
	  any arguments (including 0) above and beyond the number of
	  arguments specified for the proc.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
proc addlist {lst} {
    set res 0
    foreach e $lst {
	incr $res $e
    }
    return $res
}

puts [addlist {1 2 3 4 5}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>15</screen>
      </refsect1>
      <refsect1>
	<title>args Example</title>
	  <programlisting>
proc showargs {args} {
    puts "Args: $args"
}
showargs
showargs x y z
	</programlisting>
	<para>Produces:</para>
	<screen>Args: 
Args: x y z</screen>
      </refsect1>
    </refentry>

     <!-- puts -->
     <refentry id="puts">
      <refnamediv>
	<refname>puts</refname>
	<refpurpose>Print text.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>puts</command>
	  <arg choice="req"><replaceable>text</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>puts</command> command prints
	  <option><replaceable>text</replaceable></option> to stdout.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts "Hello, world"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>Hello, world</screen>
      </refsect1>
    </refentry>

    <refentry id="rename">
      <refnamediv>
	<refname>rename</refname>
	<refpurpose>Rename a command</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>rename</command>
	  <arg choice="req"><replaceable>cmdname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>Renames a Hecl command.</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<screen>
hecl> rename puts send_it_to_the_screen
hecl> send_it_to_the_screen "hello world"
hello world
	</screen>
      </refsect1>
    </refentry>

    <!-- return -->
    <refentry id="return">
      <refnamediv>
	<refname>return</refname>
	<refpurpose>Returns a value from a procedure.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>return</command>
	  <arg choice="req"><replaceable>value</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>return</command> command returns a value from a
	  <command>proc</command> command.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
proc someproc {} {
    set res 1
    return $res
    set res 2
    return $res
}
puts [someproc]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1</screen>
      </refsect1>
    </refentry>

    <!-- search -->
    <refentry id="search">
      <refnamediv>
	<refname>search</refname>
	<refpurpose>Find the first instance of something in a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>search</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>search</command> command is similar to
	  <command>filter</command> in functionality, except that it
	  stops searching on the first match.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set lst {1 2 3 4 5 4 3 2 1}
puts [search $lst x {= $x 4}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4</screen>
      </refsect1>
    </refentry>

    <!-- set -->
    <refentry id="set">
      <refnamediv>
	<refname>set</refname>
	<refpurpose>Set a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>set</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="opt"><replaceable>value</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>set</command> sets the value of a variable
	  <option><replaceable>varname</replaceable></option> to value
	  <option><replaceable>value</replaceable></option>. If
	  <option><replaceable>value</replaceable></option> is not
	  provided, returns the value of
	  <option><replaceable>varname</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo "bar"
set bee bop
puts "foo is $foo and bee is $bee"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1
foo is bar and bee is bop
</screen>
      </refsect1>
    </refentry>

     <!-- sort -->
     <refentry id="sort">
      <refnamediv>
	<refname>sort</refname>
	<refpurpose>Sorts list alphabetically.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>sort</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>sort</command> command returns an
	  alphabetically sorted list of the contents of
	  <option><replaceable>list</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [sort {padova rovigo verona vicenza venezia treviso belluno}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>belluno padova rovigo treviso venezia verona vicenza
</screen>
      </refsect1>
    </refentry>

    <!-- split -->
    <refentry id="split">
      <refnamediv>
	<refname>split</refname>
	<refpurpose>Split a string into a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>split</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="opt"><replaceable>splitstring</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>split</command> command takes a string and
	  splits it into a list, divided by
	  <option><replaceable>splitstring</replaceable></option>,
	  which defaults to " " if not present.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [split "aaa;bbb;ccc" ";"]
puts [split "aaa bbb ccc"]
puts [split "aaaxbbbycccxyddd" "xy"]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>aaa bbb ccc
aaa bbb ccc
aaaxbbbyccc ddd</screen>
      </refsect1>
    </refentry>

     <refentry id="strbytelen">
      <refnamediv>
	<refname>strbytelen</refname>
	<refpurpose>Return the length of the string, in bytes.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strbytelen</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strbytelen</command> returns the length of
	  <option><replaceable>string</replaceable></option>, in
	  bytes.  The number of characters and bytes may be different
	  because of multi byte character encodings.
	</para>
      </refsect1>
    </refentry>

    <refentry id="strcmp">
      <refnamediv>
	<refname>strcmp</refname>
	<refpurpose>Compare two strings, return 0 if equal.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strcmp</command>
	  <arg choice="req"><replaceable>stringA</replaceable></arg>
	  <arg choice="req"><replaceable>stringB</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strcmp</command> takes two strings and compares
	  them, returning 0 if they are equal, 1 if the first string
	  is "greater than" the second string, or -1 if the first
	  string is "less than" the second string.
	</para>
      </refsect1>
    </refentry>

    <refentry id="strfind">
      <refnamediv>
	<refname>strfind</refname>
	<refpurpose>Find one string in another.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strfind</command>
	  <arg choice="req"><replaceable>string1</replaceable></arg>
	  <arg choice="req"><replaceable>string2</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strfind</command> looks for the first occurence
	  of <replaceable>string1</replaceable> in
	  <replaceable>string2</replaceable>.  If it finds a match, it
	  returns the index where the first letter of the match lies.
	  If it is not found, it returns -1.
	</para>
      </refsect1>
    </refentry>

    <refentry id="strindex">
      <refnamediv>
	<refname>strindex</refname>
	<refpurpose>Return the index'th character of string.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strindex</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="req"><replaceable>index</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strindex</command> command returns the
	  <option><replaceable>index</replaceable></option>'th
	  character of <option><replaceable>string</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [strindex "Hello, world" 0]
puts [strindex "Hello, world" 11]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>H
d</screen>
      </refsect1>
    </refentry>

    <refentry id="strlast">
      <refnamediv>
	<refname>strlast</refname>
	<refpurpose>Get the last occurance of one string within
	another string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strlast</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="req"><replaceable>string_to_search</replaceable></arg>
	  <arg choice="opt"><replaceable>start_index</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>

	<para>
	  Search <replaceable>string_to_search</replaceable> for the
	  last place that <replaceable>string</replaceable> occurs,
	  and return the index.  If
	  <replaceable>start_index</replaceable> is provided, start
	  searching from that position.
	</para>
      </refsect1>
    </refentry>

    <!-- strlen -->
    <refentry id="strlen">
      <refnamediv>
	<refname>strlen</refname>
	<refpurpose>String length.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strlen</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strlen</command> returns the length of
	  <option><replaceable>string</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [strlen "abcdefghijklmnopqrstuvwxyz"]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>26</screen>
      </refsect1>
    </refentry>

    <refentry id="strlower">
      <refnamediv>
	<refname>strlower</refname>
	<refpurpose>Lower case a string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strlower</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>The <command>strlower</command> command returns a
	  lower-cased version of <replaceable>string</replaceable>.</para>
      </refsect1>
    </refentry>

    <refentry id="strrange">
      <refnamediv>
	<refname>strrange</refname>
	<refpurpose>Return a substring from a string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strrange</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="req"><replaceable>start</replaceable></arg>
	  <arg choice="req"><replaceable>end</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title> 

	<para>The
	  <command>strrange</command> command returns a substring
	  composed of the characters in
	  <replaceable>string</replaceable> from positions
	  <replaceable>start</replaceable> to
	  <replaceable>end</replaceable>.
	</para>
      </refsect1>
    </refentry>

    <refentry id="strrep">
      <refnamediv>
	<refname>strrep</refname>
	<refpurpose>Repeat a string N times</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strrep</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="req"><replaceable>times</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>

	<para>The <command>strrep</command> command returns
	  <replaceable>times</replaceable> copies of
	  <replaceable>string</replaceable>.
	</para>
      </refsect1>
    </refentry>

    <refentry id="strtrim">
      <refnamediv>
	<refname>strtrim</refname>
	<refpurpose>Remove whitespace or other characters from the
	beginning/end of a string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strtrim</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="opt"><replaceable>totrim</replaceable></arg>
	  <command>strtriml</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="opt"><replaceable>totrim</replaceable></arg>
	  <command>strtrimr</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="opt"><replaceable>totrim</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>

	<para>The <command>strtrim</command> command "trims" any
	leading or trailing whitespace from the string passed to it.
	The <command>strtriml</command> and
	<command>strtrimr</command> commands trim from, and only from,
	the left and right sides of the string, respectively.  All of
	the trim commands take an optional argument that specifies
	what exactly to trim.
	</para>
      </refsect1>

      <refsect1>
	<title>Examples</title>
	<screen>
hecl> strtrim " foo "
foo
hecl> strtrim "hello world" "he"
llo world
hecl> strtriml "xxxyyyzzzxxx" xxx
yyyzzzxxx
hecl> strtrim "        alone          "
alone
	</screen>
      </refsect1>
    </refentry>

    <refentry id="strupper">
      <refnamediv>
	<refname>strupper</refname>
	<refpurpose>Upper case a string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strupper</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strupper</command> command returns a
	  upper-cased version of <replaceable>string</replaceable>.
	</para>
      </refsect1>
    </refentry>

    <refentry id="throw">
      <refnamediv>
	<refname>throw</refname>
	<refpurpose>Generates an exception that can be caught with
	  <command>catch</command></refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>throw</command>
	  <arg choice="req"><replaceable>message</replaceable></arg>
	  <arg choice="opt"><replaceable>errortype</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>

      <refsect1>
	<title>Description</title>
	<para>
	  The <command>throw</command> command generates an exception,
	  that can be caught with the <command>catch
	  command</command>.  <replaceable>message</replaceable> is a
	  human readable error message, whereas
	  <replaceable>errortype</replaceable> is a code that can be
	  matched by code doing a <command>catch</command>.  It can be
	  used as a way for Hecl programs to distinguish between
	  different types of errors in a global catch section of code.
	</para>
      </refsect1>

      <refsect1>
	<title>Examples</title>
	<screen>
hecl> throw "oh no"
{ERROR {oh no}} {throw 1}
hecl> throw "oh no" USERERROR
{USERERROR {oh no}} {throw 1}
	</screen>
      </refsect1>
    </refentry>

    <!-- time -->
    <refentry id="time">
      <refnamediv>
	<refname>time</refname>
	<refpurpose>Time the execution of a script.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>time</command>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	  <arg choice="opt"><replaceable>repetitions</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>time</command> command executes
	  <option><replaceable>script</replaceable></option>
	  <option><replaceable>repetitions</replaceable></option>
	  times, if
	  <option><replaceable>repetitions</replaceable></option> is
	  present, or once if not.  It measures the amount of time
	  taken by this execution in milliseconds, and returns it.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set time [time {
    set i 0
    while { &lt; $i 100 } {
	incr $i
    }
} 10]
puts "Time is $time"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>Time is 6</screen>
      </refsect1>
    </refentry>

     <!-- true -->
     <refentry id="true">
      <refnamediv>
	<refname>true</refname>
	<refpurpose>Returns true.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>true</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>true</command> command returns 1, or true.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if { true } {
    puts "true is true"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>true is true</screen>
      </refsect1>
    </refentry>

    <!-- unset -->
    <refentry id="unset">
      <refnamediv>
	<refname>unset</refname>
	<refpurpose>Unset a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>unset</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>unset</command> command unsets a variable.
	</para>
      </refsect1>
    </refentry>

    <!-- upeval -->
    <refentry id="upeval">
      <refnamediv>
	<refname>upeval</refname>
	<refpurpose>Evaluate script in next stack frame up.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>upeval</command>
	  <arg choice="opt"><replaceable>level</replaceable></arg>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>upeval</command> command evaluates
	  <option><replaceable>script</replaceable></option> one stack
	  frame up from the current stack frame, if
	  <option><replaceable>level</replaceable></option> is not
	  present.  If
	  <option><replaceable>level</replaceable></option> is
	  present, <command>upeval</command> behaves like so: if
	  <option><replaceable>level</replaceable></option> is less
	  than one, the
	  <option><replaceable>script</replaceable></option> is run
	  that many levels down from the top of the stack.  If it's 0,
	  the script is run at the global level, and if it's a
	  positive number, the script is run at that absolute level up
	  from the global namespace.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
proc stackframe {} {
    upeval { incr $foo }
}
set foo 1
stackframe
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2</screen>
      </refsect1>
    </refentry>

    <!-- while -->
    <refentry id="while">
      <refnamediv>
	<refname>while</refname>
	<refpurpose>While loop.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>while</command>
	  <arg choice="req"><replaceable>condition</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>while</command> command continues to evaluate
	  <option><replaceable>body</replaceable></option> while
	  <option><replaceable>condition</replaceable></option> is true.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set i 0
while { &lt; $i 6 } {
    puts "i is $i"
    incr $i
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>i is 0
i is 1
i is 2
i is 3
i is 4
i is 5
</screen>
      </refsect1>
    </refentry>

<!--
     <refentry id="append">
      <refnamediv>
	<refname>append</refname>
	<refpurpose>Append text to a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>append</command>
	  <arg choice="req"><replaceable>varreference</replaceable></arg>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The append command takes two arguments, a variable reference, and a string to append to the variable.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo "bar"
append $foo "beebop"
# The foo variable now contains the string barbeebop
	  </programlisting>
	  <para>Produces:</para>
	  <screen>barbeebop</screen>
      </refsect1>
    </refentry>
-->

  </section>

  <section id="extensioncommands">
    <title>Hecl Extension Commands</title>

    <para>
      These commands are available in various Hecl extensions, that
      may or may not be available in different environments.
    </para>

    <section>
      <title>File Interaction</title>
      <para>
	J2ME systems do not always have a file system, so these are
	not necessarily available for that environment.
      </para>

      <!-- cd -->
      <refentry id="cd">
	<refnamediv>
	  <refname>cd</refname>
	  <refpurpose>Change working directory.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>cd</command>
	    <arg choice="req"><replaceable>directory</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>cd</command> command changes the current
	    working directory to
	    <option><replaceable>directory</replaceable></option>.  Or
	    at least it changes where <emphasis>Java</emphasis> thinks
	    the working directory is.  It does not change the process'
	    actual working directory.  Apparently that's not possible
	    with Java.
	  </para>
	</refsect1>
      </refentry>

      <!-- copy -->
      <refentry id="copy">
	<refnamediv>
	  <refname>copy</refname>
	  <refpurpose>Copy a Hecl value.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>cd</command>
	    <arg choice="req"><replaceable>value</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>copy</command> command makes a deep copy of a
	    Hecl value, whereas normally, Hecl variables contain
	    references.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>hecl&gt; set foo 1
set bee $foo
set bop [copy $foo]
incr $foo
puts "foo is $foo"
puts "bee is $bee"
puts "bop is $bop"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>foo is 2
bee is 2
bop is 1
</screen>
	</refsect1>
      </refentry>

      <!-- currentfile -->
      <refentry id="currentfile">
	<refnamediv>
	  <refname>currentfile</refname>
	  <refpurpose>The file currently being sourced.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>currentfile</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>currentfile</command> command returns the
	    filename of the file currently being sourced.
	  </para>
	</refsect1>
      </refentry>

      <!-- filetolist -->
      <refentry id="filetolist">
	<refnamediv>
	  <refname>filetolist</refname>
	  <refpurpose>Takes a filename and returns a list.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>filetolist</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>filetolist</command> command takes an argument,
	    <option><replaceable>filename</replaceable></option>, and
	    returns a list of all the file's directory components.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>hecl> filetolist /var/lib/dpkg/info
/ var lib dpkg info
	  </programlisting>
	</refsect1>
      </refentry>


      <!-- listtofile -->

      <refentry id="listtofile">
	<refnamediv>
	  <refname>listtofile</refname> <refpurpose>List to file takes
	  a list and transforms it into a filename, adding the correct
	  file seperator for the platform in question.
	  </refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>listtofile</command>
	    <arg choice="req"><replaceable>list</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>listtofile</command> command takes a list and
	    returns a filename.  The filename doesn't need to exist on
	    the system.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>hecl> set lst [list / etc passwd]
/ etc passwd
hecl> listtofile $lst
/etc/passwd
	  </programlisting>
	</refsect1>
      </refentry>


      <!-- readall -->

      <refentry id="readall">
	<refnamediv>
	  <refname>readall</refname>
	  <refpurpose>Reads an entire file and returns its contents.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>readall</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>readall</command> command reads an entire
	    file and returns its contents.
	    <option><replaceable>filename</replaceable></option>.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set data [readall foo.txt]
set lines [split $data "\n"]
set i 1
foreach line $lines {
    puts "$i $line"
    incr $i
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1 .....
2 ........
3 ........
etc...</screen>
	</refsect1>
      </refentry>


      <!-- source -->
      <refentry id="source">
	<refnamediv>
	  <refname>source</refname>
	  <refpurpose>Evaluate Hecl script in a file.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>source</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>source</command> command evaluates the Hecl
	    script located in file
	    <option><replaceable>filename</replaceable></option>.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
# Variable foo is defined as "Hello world" in foo.hcl
source foo.hcl
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>Hello world</screen>
	</refsect1>
      </refentry>
    </section>

    <section>
      <title>HTTP</title>

      <para>
	Even basic J2ME-enabled cell phones can access web pages
	(although they may not be able to create TCP/IP sockets).  Hecl
	provides basic http commands</para>

      <!-- http -->
      <refentry id="http_geturl">
	<refnamediv>
	  <refname>http.geturl</refname>
	  <refpurpose>Fetch contents of a URL.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.geturl</command>
	    <arg choice="req"><replaceable>url</replaceable></arg>
	    <arg choice="opt">-query <replaceable>POSTdata</replaceable></arg>
	    <arg choice="opt">-headers <replaceable>list of headers</replaceable></arg>
	    <arg choice="opt">-validate [1|0]</arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>http.geturl</command> command performs an
	    HTTP request to the given
	    <option><replaceable>url</replaceable></option> and
	    returns information about the results.  This information
	    is returned as a hash table that can be accessed with the
	    various h* commands such as hget.  The list of keys
	    returned includes the following, which are set by Hecl.
	    Also created as keys are the various HTTP headers, such as
	    connection, content-length, content-type, last-modified,
	    and so on.
	  </para>
	  <simplelist>
	    <member><constant>binary</constant>: 1 if the data
	    returned is binary, otherwise 0.</member>

	    <member><constant>charset</constant>: The charset used for
	    the returned data.</member>

	    <member><constant>data</constant>: The returned data.</member>

	    <member><constant>ncode</constant>: The numeric code of
	    the response, such as 404, 500, 301, and so on.</member>

	    <member><constant>status</constant>: The request status -
	    ok if the request was successfully processed.</member>
	  </simplelist>
	  <para>
	    The <option>-query</option> option is used to send
	    key/value pairs of variables.  In order to set random
	    headers, the <option>-headers</option> argument is used.
	    The <option>-validate</option> option exists to send a
	    <constant>HEAD</constant> request.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
# Evaluate Hecl script located on a web site.
eval [hget [http.geturl http://www.hecl.org/somescript.hcl] data]
	  </programlisting>
	</refsect1>
      </refentry>

      <refentry id="http_formatQuery">
	<refnamediv>
	  <refname>http.formatQuery</refname>
	  <refpurpose>URL Encode a request</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.formatQuery</command>
	    <arg choice="opt"><replaceable>key</replaceable>
	    <replaceable>val</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>The <command>http.formatQuery</command> command takes
	  a series of key value pairs and urlencodes them.  Useful in
	    order to pass data to the <option>-query</option> option
	    of <command>http.geturl</command></para>
	</refsect1>
      </refentry>

      <refentry id="http_data">
	<refnamediv>
	  <refname>http.data</refname>
	  <refpurpose>A shortcut to get the data from an http.geturl response.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.data</command>
	    <arg choice="req"><replaceable>request</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>http.data</command> command is equivalent to
	    an <command>hget</command> with <constant>data</constant>
	    as the key.
	  </para>
	  <programlisting>http.data [http.geturl http://www.dedasys.com]</programlisting>
	</refsect1>
      </refentry>

      <refentry id="http_ncode">
	<refnamediv>
	  <refname>http.ncode</refname>
	  <refpurpose>A shortcut to get the numeric code from an http.geturl response.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.ncode</command>
	    <arg choice="req"><replaceable>request</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>http.data</command> command is equivalent to
	    an <command>hget</command> with <constant>ncode</constant>
	    as the key.
	  </para>
	  <programlisting>http.ncode [http.geturl http://www.dedasys.com]</programlisting>
	</refsect1>
      </refentry>

      <refentry id="http_status">
	<refnamediv>
	  <refname>http.status</refname>
	  <refpurpose>A shortcut to get the status from an http.geturl response.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.status</command>
	    <arg choice="req"><replaceable>request</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>http.status</command> command is equivalent to
	    an <command>hget</command> with <constant>status</constant>
	    as the key.
	  </para>
	  <programlisting>http.status [http.geturl http://www.dedasys.com]</programlisting>
	</refsect1>
      </refentry>


    </section>

    <section>
      <title>Net</title>

      <para>Networking commands</para>

      <refentry id="base64_decode">
	<refnamediv>
	  <refname>base64::decode</refname>
	  <refpurpose>Base 64 decode</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>base64::decode</command>
	    <arg choice="req"><replaceable>encoded-data</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>base64::decode</command> command does a
	    base64 decode of the string passed to it.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="base64_encode">
	<refnamediv>
	  <refname>base64::encode</refname>
	  <refpurpose>Base 64 encode</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>base64::encode</command>
	    <arg choice="req"><replaceable>data</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>base64::encode</command> command does a
	    base64 encode of the string passed to it.
	  </para>
	</refsect1>
      </refentry>


    </section>

  </section>


  <section id="heclandjava">
    <title>Interfacing Hecl and Java</title>

    <section>
      <title>Calling Hecl code from Java</title>
      <para>
	Hecl is not a replacement for Java, and is indeed meant to
	work hand in hand with Java.  We attempt to make it as easy as
	possible to call Java from Hecl, via the creation of new Hecl
	commands that can call Java code, in addition to calling Hecl
	from Java, which is a matter of a few lines of code.  For
	example, to evaluate a Hecl file from Java:
      </para>

      <programlisting>
import org.hecl.files.HeclFile;

import org.hecl.Eval;
import org.hecl.Interp;
import org.hecl.Thing;
import org.hecl.ListThing;
import org.hecl.HeclException;
      </programlisting>
...
      <programlisting>

	try {
	    /* First, create a new interpreter, and pass it a
	     * mechanism to load resources with - in this case,
	     * files. */
	    Interp interp = new Interp();

	    /* Add the files package  */
	    new HeclFile().loadModule(interp);
	    /* Evaluate the file at args[0] */
	    HeclFile.sourceFile(interp, args[0]);
	    /* Evaluate some code in a string.  */
	    String helloworld = new String("puts {Hello, world!}");
	    interp.eval(new Thing(helloworld));
	} catch (Exception e) {
	    System.err.println(e);
	}
      </programlisting>

      <para>
	The above code first creates a new interpreter.  Next, it
	instantiates the HeclFile system.  This isn't part of the Hecl
	core, because some systems, like J2ME, may not have files.  If
	you don't have files, you can still use
	<methodname>interp.eval</methodname> to evaluate some code,
	which could come from whatever source you desire.
      </para>
    </section>

    <section>
      <title>Creating new Hecl commands</title>

      <para>
	Creating new Hecl commands is relatively simple.  The first
	step is to create a new class for your command in a file, say
	<filename>HelloCmd.java</filename>.  The code would look
	something like this:
      </para>

      <programlisting>
import org.hecl.Command;
import org.hecl.HeclException;
import org.hecl.Interp;
      </programlisting>

      <para>...</para>

      <programlisting>
class HelloCmd implements Command {

    public void cmdCode(Interp interp, Thing[] argv)
	throws HeclException {

	System.out.println("Hello world");
    }
}
      </programlisting>

      <para>
	The command takes an interpreter and an array of
	<classname>Thing</classname>s as arguments, where the first
	<classname>Thing</classname> is the name of the command
	itself, and the others are the arguments to it.
      </para>

      <para>
	The "glue" that connects the name of your Hecl command with
	the Java code is also relatively simple:
      </para>

      <programlisting>
	interp.commands.put("hello", new HelloCmd());
      </programlisting>

      <para>
	Easy, no?  There are a few other useful methods that you
	should be aware of, to share variables between Hecl and Java,
	and to return results from your Hecl commands:
      </para>

      <itemizedlist>
	<listitem>
	  <methodsynopsis>
	    <methodname>interp.setVar</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>varname</parameter>
	    </methodparam>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>value</parameter>
	    </methodparam>
	  </methodsynopsis>
	  This sets the value of <parameter>varname</parameter> to
	  some value.
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>Thing</type>
	    <methodname>interp.getVar</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>varname</parameter>
	    </methodparam>
	  </methodsynopsis>

	  <methodsynopsis>
	    <type>Thing</type>
	    <methodname>interp.getVar</methodname>
	    <methodparam>
	      <type>String</type>
	      <parameter>varname</parameter>
	    </methodparam>
	  </methodsynopsis>
	  These methods take a variable name, either in string form or
	  as a <classname>Thing</classname>, and return the
	  <classname>Thing</classname> associated with that variable.
	</listitem>

	<listitem>
	  <para><varname>interp.result</varname> is used to set the
	    result of a command.  This oft-used variable is accessed
	    directly for simplicity, speed and smaller code size.
	  </para>
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>int</type>
	    <methodname>IntThing.get</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>thing</parameter>
	    </methodparam>
	  </methodsynopsis>
	  Get an int from a Thing.
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>String</type>
	    <methodname>StringThing.get</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>thing</parameter>
	    </methodparam>
	  </methodsynopsis>
	  Get a String from a Thing.
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>Thing</type>
	    <methodname>IntThing.create</methodname>
	    <methodparam>
	      <type>int</type>
	      <parameter>i</parameter>
	    </methodparam>
	  </methodsynopsis>
	  Creates a new thing from an int.
	</listitem>

      </itemizedlist>

    </section>

    <section>
      <title>JavaDocs</title>

      <para>
	For the complete Hecl javadoc documentation, see the <ulink
	  url="jdocs">Hecl Javadocs</ulink>.  And, of course, look at
	  the Hecl source code to see how it's done!
      </para>

    </section>

  </section>


  <section id="j2me">
    <title>Hecl and J2ME</title>

    <para>
      Hecl is designed to be small enough to run on mobile devices
      such as cell phones.  This means that for the Hecl core, has
      been necessary to limit ourselves to Java API's that work with
      J2ME.
    </para>

    <section id="j2mecommands">
      <title>Hecl J2ME Commands</title>

      <note>
	Hecl has different GUI commands for the MIDP1.0 (older phones)
	and MIDP2.0 (newer, with more memory).  We are in the process
	of documenting the MIDP2.0 commands.
      </note>

      <para>
	Commands available in the J2ME MIDP1.0 version of Hecl to
	interact with the phone.  Look in the
	<filename>midp10/examples</filename> directory for examples of
	these commands and widgets in use.
      </para>

      <refentry id="alert">
	<refnamediv>
	  <refname>alert</refname>
	  <refpurpose>Creates an alert</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>alert</command>
	    <arg choice="opt">label <replaceable>title</replaceable></arg>
	    <arg choice="opt">text <replaceable>text</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">alarm</arg>
		<arg choice="req">confirmation</arg>
		<arg choice="req">error</arg>
		<arg choice="req">error</arg>
		<arg choice="req">info</arg>
		<arg choice="req">warning</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>Alert</classname> class.  You must
	    call <command>setcurrent</command> to actually display the
	    alert.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="choicegroup">
	<refnamediv>
	  <refname>choicegroup</refname>
	  <refpurpose>Displays a choicegroup in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>choicegroup</command>
	    <arg choice="opt">label <replaceable>label</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">exclusive</arg>
		<arg choice="req">implicit</arg>
		<arg choice="req">multiple</arg>
	      </group>
	    </arg>
	    <arg choice="opt">list <replaceable>list</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>ChoiceGroup</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="cmd">
	<refnamediv>
	  <refname>cmd</refname>
	  <refpurpose>Adds a command to a form/listbox/textbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>cmd</command>
	    <arg choice="opt">label <replaceable>label</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">back</arg>
		<arg choice="req">cancel</arg>
		<arg choice="req">exit</arg>
		<arg choice="req">help</arg>
		<arg choice="req">item</arg>
		<arg choice="req">ok</arg>
		<arg choice="req">screen</arg>
		<arg choice="req">stop</arg>
	      </group>
	    </arg>
	    <arg choice="opt">code <replaceable>code</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    This is used to create and associate commands with a
	    screen widget (form, listbox, textbox). The lcdui
	    <classname>Command</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="datefield">
	<refnamediv>
	  <refname>datefield</refname>
	  <refpurpose>Displays an datefield in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>datefield</command>
	    <arg choice="opt">label</arg>
	    <arg choice="opt">typ
	      <group>
		<arg choice="req">date_time</arg>
		<arg choice="req">date</arg>
		<arg choice="req">time</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>DateField</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="j2me_exit">
	<refnamediv>
	  <refname>exit</refname>
	  <refpurpose>Exits the application</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>exit</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Exits the application.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="form">
	<refnamediv>
	  <refname>form</refname>
	  <refpurpose>Creates a form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>form</command>
	    <arg choice="opt">label <replaceable>title</replaceable></arg>
	    <arg choice="opt">code <replaceable>code</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>Form</classname> class.  Note that in
	    order to actually display the newly created form, you must
	    call the <command>setcurrent</command> command with a
	    reference to the form as an argument.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="gauge">
	<refnamediv>
	  <refname>gauge</refname>
	  <refpurpose>Displays an gauge in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>gauge</command>
	    <arg choice="opt">label <replaceable>label</replaceable></arg>
	    <arg choice="opt">maxval
	    <replaceable>maximum_value</replaceable></arg>
	    <arg choice="opt">val
	    <replaceable>initial_value</replaceable></arg>
	    <arg choice="opt">interactive
	      <group>
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>Gauge</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="getindex">
	<refnamediv>
	  <refname>getindex</refname>
	  <refpurpose>Fetches a reference to the N'th element in a
	  given form/listbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>getindex</command>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	    <arg choice="req"><replaceable>index</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Fetches the N'th element in a form.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="getprop">
	<refnamediv>
	  <refname>getprop</refname>
	  <refpurpose>Fetches the value of a given property from a widget</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>getprop</command>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	    <arg choice="req"><replaceable>property</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Fetches the value of a given property.  For example:
	  </para>
	  <programlisting>
	    set tf [textfield label "Insert text:"]
	    ...
	    set inserted_text [getprop $tf text]
	  </programlisting>
	  <para>
	    In this example, <command>getprop</command> fetches the
	    text that has been inserted in the textfield.
	    <option><replaceable>property</replaceable></option> must
	    be a valid property for the given widget.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="listbox">
	<refnamediv>
	  <refname>listbox</refname>
	  <refpurpose>Creates a listbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>listbox</command>
	    <arg choice="opt">label <replaceable>title</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">exclusive</arg>
		<arg choice="req">implicit</arg>
		<arg choice="req">multiple</arg>
	      </group>
	    </arg>
	    <arg choice="opt">code
	    <replaceable>code</replaceable></arg>
	    <arg choice="opt">callback <replaceable>code</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Similar to the lcdui <classname>ListBox</classname> class,
	    but implemented as a class that extends
	    <classname>Form</classname>, in order to enable the use of
	    callbacks.  Like forms and textboxes, it is necessary to
	    use the <command>setcurrent</command> command to actually
	    display a listbox.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="noscreen">
	<refnamediv>
	  <refname>noscreen</refname>
	  <refpurpose>Runs without a current screen widget</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>noscreen</command>
	    <arg choice="req">code</arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Normally, there is almost always a default screen widget
	    present, so that when items are created, they are
	    automatically added to the screen widget that is in
	    effect.  The <command>noscreen</command> command executes
	    the code passed to it without a default screen widget.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="screenappend">
	<refnamediv>
	  <refname>screenappend</refname>
	  <refpurpose>Appends an item to a form or listbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>screenappend</command>
	    <arg
	    choice="req"><replaceable>screen_widget</replaceable></arg>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Appends an
	    <option><replaceable>widget</replaceable></option> to the
	    form or listbox
	    <option><replaceable>screen_widget</replaceable></option>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="setcurrent">
	<refnamediv>
	  <refname>setcurrent</refname>
	  <refpurpose>Displays an alert/form/listbox/textbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>setcurrent</command>
	    <arg choice="req">screen_widget</arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Screen widgets (alerts, forms, listboxes and textboxes),
	    are not displayed when created.
	    <command>setcurrent</command> displays them.  For example:
	  </para>
	  <programlisting>
	    set f [form label "New Form"]
	    setcurrent $f
	  </programlisting>
	</refsect1>
      </refentry>

      <refentry id="setindex">
	<refnamediv>
	  <refname>setindex</refname>

	  <refpurpose>
	    Sets the
	    <option><replaceable>index</replaceable></option>th
	    element in a form/listbox to specified item</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>setindex</command>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	    <arg choice="req"><replaceable>index</replaceable></arg>
	    <arg choice="req"><replaceable>newitem</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Sets the
	    <option><replaceable>index</replaceable></option>'th item
	    of a form/listbox to item
	    <option><replaceable>newitem</replaceable></option>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="setprop">
	<refnamediv>
	  <refname>setprop</refname>
	  <refpurpose>Sets a given property of a widget</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>setprop</command>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	    <arg
	    choice="req"><replaceable>property</replaceable></arg>
	    <arg choice="req"><replaceable>new_value</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Sets the value of a given widget's property.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="string">
	<refnamediv>
	  <refname>string</refname>
	  <refpurpose>Adds a string to the current form.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>string</command>
	    <arg choice="req"><replaceable>string</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Appends the specified
	    <option><replaceable>string</replaceable></option> to the
	    current form.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="stringitem">
	<refnamediv>
	  <refname>stringitem</refname>
	  <refpurpose>Displays a stringitem in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>stringitem</command>
	    <arg choice="opt">label <replaceable>label</replaceable></arg>
	    <arg choice="opt">text <replaceable>text</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>StringItem</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="textbox">
	<refnamediv>
	  <refname>textbox</refname>
	  <refpurpose>Creates a textbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>textbox</command>
	    <arg choice="opt">label <replaceable>title</replaceable></arg>
	    <arg choice="opt">len <replaceable>length_in_characters</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">any</arg>
		<arg choice="req">emailaddr</arg>
		<arg choice="req">numeric</arg>
		<arg choice="req">phonenumber</arg>
		<arg choice="req">passwd</arg>
		<arg choice="req">url</arg>
	      </group>
	    </arg>
	    <arg choice="opt">text
	    <replaceable>text</replaceable></arg>
	    <arg choice="opt">code <replaceable>code</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>TextBox</classname> class.  To
	    display a textbox, you must use the
	    <command>setcurrent</command> command.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="textfield">
	<refnamediv>
	  <refname>textfield</refname>
	  <refpurpose>Displays a textfield in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>textfield</command>
	    <arg choice="opt">label
	    <replaceable>label</replaceable></arg>
	    <arg choice="opt">len <replaceable>length_in_characters</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">any</arg>
		<arg choice="req">emailaddr</arg>
		<arg choice="req">numeric</arg>
		<arg choice="req">phonenumber</arg>
		<arg choice="req">passwd</arg>
		<arg choice="req">url</arg>
	      </group>
	    </arg>
	    <arg choice="opt">text <replaceable>text</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>TextField</classname> class.
	  </para>
	</refsect1>
      </refentry>

    </section>

    <section id="heclapps">
      <title>Creating your own Hecl J2ME apps</title>

      <para>
	Creating new hecl applications is relatively easy using the
	<application>HeclBuilder</application> application.
      </para>

      <procedure>
	<step>

	  <para>
	    Launch it like so:
	  </para>

	  <screen>java -jar jars/HeclBuilder.jar</screen>

	  <para>
	    It should look something like this:
	  </para>

	  <screenshot>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="heclbuilder-screen.png" format="PNG"/>
	      </imageobject>
	      <caption>
		HeclBuilder in action
	      </caption>
	    </mediaobject>
	  </screenshot>

	</step>

	<step>
	  <para>
	    First, you must select a script to use for your Hecl
	    application.  We recommend that you create this yourself
	    using your favorite editor (if it has a Tcl mode, that
	    will make things even easier).  The provided editor is not
	    yet really worthy of the name!
	  </para>
	</step>

	<step>
	  <para>
	    The next field (<guilabel>MIDlet name</guilabel>) is the
	    name of your Hecl application.  This will be used both as
	    the name visible on the cell phone, as well as the name of
	    the .jar file.
	  </para>
	</step>

	<step>
	  <para>
	    Select a directory where the resulting .jar and .jad files
	    will be placed.
	  </para>
	</step>

	<step>
	  <para>
	    At this point, all you have to do is press the "Go"
	    button, and the .jar and .jad files will be created for
	    you.  All that's left is to move them on to the cell
	    phone, but we can't do that for you, as there is no
	    standard method - each phone manufacturer provides their
	    own way.  On Linux, I use the following command:
	  </para>
	  <screen>gammu nothing --nokiaaddfile Application Hecl</screen>
	</step>

	<step performance="optional">
	  <para>
	    If you have some sort of J2ME SDK that includes an
	    emulator, now would be a good time to try out your
	    application before running it on your phone.  You can get
	    that is free (if not open source) from Sun here: <ulink
	    url="http://java.sun.com/products/sjwtoolkit/">http://java.sun.com/products/sjwtoolkit/</ulink>
	    .  I run it like this:
	  </para>

	  <screen>~/Desktop/WTK2.2/bin/emulator -classpath MyApp.jar Hecl</screen>

	  <para>
	    Note that <option>Hecl</option> above will not change,
	    because that is always the main class, even if the
	    application itself has a different name.
	  </para>

	</step>
      </procedure>

      <para>
	This leads to a very quick development cycle - if you leave
	HeclBuilder open, all you have to do to update your .jar and
	.jad files after you have edited your Hecl script, is to click
	the <guibutton>Create .jar/.jad files</guibutton> button!
      </para>

    </section>

    <section>
      <title>Example application</title>

      <para>
	For example, let's create a simple form with a text entry
	widget and a command that acts on it:
      </para>

      <programlisting><xi:include href="reverse.hcl" parse="text"
	  xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>

      <para>
	This program is pretty simple.  It displays a form, which
	contains a textfield and a stringitem, and two commands,
	<command>Reverse</command> and <command>Exit</command>.  When
	you select <command>Reverse</command>, the text contained in
	the textfield is reversed, and displayed in the stringitem.
	Exit does what you might expect.
      </para>

      <para>
	The code is fairly self-explanatory, with a few key points
	worth noting.  Within the <command>reverse</command> proc,
	<command>getprop</command> and <command>setprop</command> are
	used to fetch and set properties of the textfield and
	stringitem.  All the GUI elements have fairly similar
	arguments, for instance <option>label</option> for the label,
	and <option>code</option> for the code associated with them.
	Note thouth that the code associated with the form is
	evaluated immediately, whereas that associated with the
	commands is only evaluated when they are selected.  Lastly, to
	actually display this on the screen, it's necessary to set the
	form as the screen item currently displayed.
      </para>

      <para>The program looks more or less like this when run:

      </para>

      <screenshot>
	<mediaobject>
	  <imageobject><imagedata fileref="reverse-screen.png"
	  format="PNG"/></imageobject>
	  <caption>
	    "reverse" screenshot, with textfield, stringitem, and two
	    commands, Reverse and Exit
	  </caption>
	</mediaobject>
      </screenshot>

    </section>

    <section>
      <title>Hacking Hecl's J2ME code</title>

      <para>
	Should you need to "look under the hood" (and you are
	encouraged to do so!), everything you need is in the
	<filename>midp10/</filename> directory.  The
	<filename>GUICmds.java</filename> file contains most of the
	functionality that maps J2ME functionality to Hecl and back.
	The <filename>Hecl.java</filename> file contains the code that
	starts up Hecl on the cell phone.
      </para>

      <para>
	If you want to recompile the standard Hecl.jar and .jad,
	simply use the <command>ant midlet10</command> command (or
	<command>ant midlet11</command> if you want the CLDC1.1
	version of Hecl) to create the .jar and .jad files for you,
	including your version of script.hcl.
      </para>
    </section>
  </section>
</article>
